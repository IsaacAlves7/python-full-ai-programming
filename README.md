# üß† AI - Artificial Intelligence Development ü§ñ
<blockquote>It's a repository of full AI (Artificial Intelligence) programming using the Python language.</blockquote>


<!-- <div align="left"><a href="https://github.com/IsaacAlves7/python-programming"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/python_button_icon_151925.png" height="47"></a><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/r_button_icon_151924.png" height="47"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/ai_button_icon_151919.png" height="47"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/iot_button_icon_151911.png" height="47"></div>
 -->
<a href="https://github.com/IsaacAlves7/python-ai-development"><img src="https://www.isktechnologies.com/img/blog/python-for-ai-mi-banner.jpg" width="1777"></a>

 
<blockquote>‚ö†Ô∏è <b>Warning:</b> I recommend to repeat the same activities, do the exercices and execute the codes on your own machine. Besides that, it's a repository only focused in AI development, if you need to learn the Python Language and his paradigms, click on picture below to be redirected for the Python programming repository.</blockquote>

<hr>
<h1 align="center" class="cap1">üß† AI - Artificial Intelligence üñ•Ô∏è</h1>
<img src="https://www.multimediadesignstudio.com.br/web/images/blog/inteligengia_artificial.jpg"/>
<p>Apesar de n√£o haver um consenso sobre o que seja exatamente <b>Intelig√™ncia Artificial</b>, diferentes autores procuraram definir o termo ao longo do tempo. A seguir listamos algumas dessas defini√ß√µes:</p>
<blockquote><i>"A automa√ß√£o de atividades que associamos ao pensamento humano, atividades tais como tomadas de decis√£o , resolu√ß√£o de problemas, aprendizado .." - <b>Bellman</b>, 1978.</blockquote></i>
<blockquote><i>"O estudo das computa√ß√µes que tornam poss√≠vel perceber, racionar e agir.‚Äù - <b>Winston</b>, 1992.</b></blockquote></i>
<blockquote><i>"A arte de criar m√°quinas que executem fun√ß√µes que exijam intelig√™ncia quando executadas por pessoas.‚Äù - <b>Kurzweil</b>, 1990.</b></blockquote></i>
<blockquote><i>"O estudo de como fazer computadores realizarem coisas nas quais, no momento, as pessoas s√£o melhores.‚Äù - <b>Rich and Knight</b>, 1991.</b></blockquote></i>
<blockquote><i>"O campo de estudos que procura emular comportamento inteligente em termos de processos computacionais.‚Äù - <b>Schalkoff</b>, 1990.</b></blockquote></i>
<blockquote><i>"O ramo da ci√™ncia da computa√ß√£o que est√° interessado em automatizar comportamento inteligente.‚Äù - <b>Luger e Stubblefield</b>, 1993.</b></blockquote></i>
<blockquote><i>"O campo de estudos que busca desenvolver t√©cnicas computacionais para realizar tarefas que requerem intelig√™ncia quando realizadas por seres humanos. Envolve o desenvolvimento de tecnologia que permita lidar com categorias tais como racioc√≠nio, aprendizado e percep√ß√£o.‚Äù - <b>Takimoto</b>, 1987.</b></blockquote></i>
<h2>ü§ì O que √© intelig√™ncia? ü§î</h2>
<img src="https://inteng-storage.s3.amazonaws.com/img/iea/QlO7z1Mew7/sizes/aidepositphotos_resize_md.jpg" width="1700"/>
<p>De fato, muitas das defini√ß√µes citam <i>intelig√™ncia</i> como algo que se deseja <b>simular</b>, <b>emular</b> ou <b>mimetizar</b>. Logo, uma discuss√£o anterior que se faz necess√°ria √©: ‚ÄúO que √© intelig√™ncia?‚Äù.<br>
  
Algumas possibilidades s√£o:
<ul>
  <li>Jogar xadrez?</li>
  <li>Entender a linguagem humana?</li>
  <li>Resolver problemas combinat√≥rios trabalhosos e complexos?</li>
  <li>Decidir diante a incerteza?</li>   
  <li>Reconhecer um objeto pela a imagem?</li> 
  <li>Gabaritar uma prova com o pouco de conhecimento sobre a mat√©ria?</li> 
  <li>Reconhecer o som de um objeto e saber distingui-lo?</li>   
  <li>Prever um acontecimento?</li>
  <li>Falar? Ouvir? Observar? Conversar? Responder? Perguntar? Pensar? Agir? Obedecer? Orientar? Ler? Desenhar? Cantar? Aprender? Refletir? Repetir? Interagir? Executar?  Trabalhar? Informar? Solicitar? Acessar? Proteger? Ensinar? Reconhecer? Raciocinar? Recomendar? Ou ainda mais pol√™mico... Amar?</li>
</ul>

De uma forma geral, o termo ‚Äúintelig√™ncia‚Äù √© revestido de um glamour natural e que remete a coisas, originais, inovadoras ou dif√≠ceis de realizar pelo ser humano m√©dio.

√â provavelmente mais f√°cil que algu√©m que tenha uma habilidade mental de realizar c√°lculos aritm√©ticos complexos seja considerado "inteligente", do que supor inteligente algu√©m que pode realizar tarefas cotidianas e comezinhas como falar, reconhecer o rosto de uma pessoa, rir de algo engra√ßado ou decidir quando deve atravessar uma rua com tr√°fego intenso.
</p>

<h2>üê±‚Äçüêâ Alguns paradigmas da Intelig√™ncia Artificial üê±‚Äçüèç</h2>
<p>Ao abordar tais quest√µes, os diversos paradigmas, atualmente pesquisados, obt√©m mais ou menos sucesso, de acordo com suas <b>caracter√≠sticas</b>, <b>virtudes</b> e <b>limita√ß√µes</b>. Uma abordagem ligeira desses paradigmas, que ser√£o estudados melhor ao longo da disciplina, √© feita a seguir:</p>

<h3>üå≥ Sistemas baseados em conhecimento</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)](https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#-sistemas-de-produ%C3%A7%C3%A3o-)

</div>
<ul>
  <li><b>Buscas em tabelas, √°rvores de decis√£o, busca heur√≠stica, sistemas baseados em regras</b>.</li>
  <li>Lidam com <b>conhecimento expl√≠cito e representado simbolicamente</b>.</li>  
  <li><b>Examinam o seu racioc√≠nio</b>.</li> 
  <li>Podem <b>justificar conclus√µes</b>.</li> 
  <li>Atuam mesmo com <b>conhecimento incompleto ou impreciso</b>.</li> 
  <li><b>Principais aplica√ß√µes:</b> jogos, configura√ß√µes de produtos, emiss√£o de propostas, telemarketing, distribui√ß√£o, concess√£o de cr√©dito, gest√£o de carteira, orienta√ß√£o a clientes, sele√ß√£o, or√ßamento, planejamento estrat√©gico, aloca√ß√£o de recursos, diagn√≥stico, terap√™utica, sistemas tutoriais e psico-testes.</li>   
</ul>

<h3>üß† Modelos Conexionistas (Redes Neurais)</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)]()

</div>
<ul>
  <li>Lidam com <b>conhecimento n√£o simbolicamente representado</b>.</li>
  <li>Levemente <b>inspirados no comportamento do c√©rebro e seus neur√¥nios</b>.</li>  
  <li>Processam a informa√ß√£o de <b>forma paralela e distribu√≠da</b>.</li> 
  <li>Aprendem com treinamento.</li> 
  <li><b>Generalizam o conhecimento aprendido</b>.</li> 
  <li>Por n√£o lidarem com conhecimento simb√≥lico, <b>n√£o justificam decis√µes</b>.</li>   
  <li><b>Algumas aplica√ß√µes:</b> Reconhecimento de fala, classifica√ß√£o de sinais de sensores, reconhecimento de imagens, previs√£o de √≠ndices do mercado financeiro, previs√£o de s√©ries temporais, reconhecimento de voz, aplica√ß√µes gerais de classifica√ß√£o, agrupamento e previs√£o.</li>    
</ul>

<h3>üîÄ Sistemas Nebulosos (L√≥gica Fuzzy)</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)](https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-04--l%C3%B3gica-nebulosa-fuzzy-e-sistemas-baseados-em-regras-fuzzy-)

</div>
<ul>
  <li>Modelam os <b>modos imprecisos do racioc√≠nio aproximado que influenciam na habilidade humana de tomar decis√µes</b>.</li>
  <li>Realizam o <b>racioc√≠nio aproximado, com proposi√ß√µes imprecisas, descritas em linguagem natural usando a teoria de conjuntos nebulosos como ferramenta para convert√™-las em formato num√©rico.</b></li>  
  <li><b>Algumas aplica√ß√µes:</b> controle de aeronaves, opera√ß√£o do metr√¥, transmiss√£o autom√°tica de ve√≠culos, controle de elevadores, an√°lise do mercado de a√ß√µes, ajuste da imagem de TV, autofocus para c√¢mera de v√≠deo, estabilizador de imagens de filmadoras, controle de m√°quinas de lavar e sistemas de ar condicionado.</li>    
</ul>

<h3>üß¨ Computa√ß√£o Evolucion√°ria (Algoritmos Gen√©ticos)</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)](https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-06-%EF%B8%8F-evolved-systems-and-genetic-algorithms-)

</div>
<ul>
  <li>S√£o algoritmos de otimiza√ß√£o global que baseiam-se nos mecanismos da <b>sele√ß√£o natural e da gen√©tica</b>.</li>
  <li>Empregam <b>uma estrat√©gia de busca paralela e estruturada</b>, que √© voltada em dire√ß√£o ao refor√ßo da busca de pontos de ‚Äúalta aptid√£o‚Äù.</li>  
  <li>Exploram informa√ß√µes hist√≥ricas para <b>encontrar novos pontos de busca</b>, onde s√£o esperados melhores desempenhos, atrav√©s de processos iterativos, onde <b>cada itera√ß√£o √© chamada de "gera√ß√£o"</b>.</li> 
  <li><b>Algumas aplica√ß√µes:</b> problemas gerais de roteamento, controle de sistemas din√¢micos, indu√ß√£o e otimiza√ß√£o de bases de regras, encontrar topologias conexionistas, simula√ß√£o de modelos biol√≥gicos, evolu√ß√£o interativa de imagens.</li>   
</ul>

<p>Em suma, o <b>conhecimento</b> √© a base para o desenvolvimento de modelos que envolvam <b>intelig√™ncia</b>.

A primeira t√©cnica que estudaremos, aplica-se a uma <em>classe de problemas</em> que ser√° definida mais √† frente e que √© genericamente chamada de <b>Sistemas de Produ√ß√£o</b>.</p>

<h2>üß∞ Sistemas de Produ√ß√£o ü¶æ</h2>
<img src="https://intellipaat.com/blog/wp-content/uploads/2020/05/Production-System-in-Artificial-Intelligence-Big.jpg" width="1000"/>
  
<blockquote><b>Sistemas de Produ√ß√£o</b> s√£o sistemas computacionais de <em>prop√≥sito espec√≠fico</em>, baseados em <em>conhecimento restrito e especific√°vel</em>.</blockquote> 

O tipo de problema que pode ser abordado com essa t√©cnica deve possuir tr√™s caracter√≠sticas:
<ol>
<li>A primeira delas √© que deve ser poss√≠vel <em>representar e reconhecer as situa√ß√µes est√°ticas do problema</em>, que podem ser chamadas de ‚Äú<b>estados</b>‚Äù. Ou seja, s√£o problemas caracterizados por <em>evolu√≠rem em uma sequ√™ncia de estados distintos e identific√°veis</em>.</p>
<h3>1. Exemplo: üß∞‚ôö‚ôõ‚ôú‚ôù‚ôû‚ôü Xadrez ‚ôô‚ôò‚ôó‚ôï‚ôñ‚ôîü¶æ</h3>
<p>Por exemplo, os problemas que envolvem <em>jogos de tabuleiro</em>, em geral possuem essa caracter√≠stica. Em um jogo de <b>xadrez</b>, damas ou gam√£o, a situa√ß√£o do tabuleiro ap√≥s cada lance de um dos advers√°rios caracteriza <b>um ‚Äúestado‚Äù</b> do jogo. 
<br>&nbsp;
<img src="https://blog.megajogos.com.br/wp-content/uploads/2019/10/banner_xadrez.png" width="1050" title="Chess"/>

O jogo em si √© uma sucess√£o de <i>estados distintos, reconhec√≠veis e identific√°veis</i>.</li> 

<li>Al√©m de estados, esse tipo de problema tamb√©m se caracteriza por ter ‚Äú<b>opera√ß√µes</b>‚Äù conhecidas que <em>ocasionam as mudan√ßas de estado</em>. Nos jogos de tabuleiro, por exemplo, as opera√ß√µes s√£o as movimenta√ß√µes poss√≠veis das pe√ßas, impostas pelas regras do jogo.</li>

<li>A terceira condi√ß√£o que deve estar presente √© haver um "<b>estado inicial</b>" e um ou mais "<b>estados finais</b>" a serem atingidos. Nos jogos de tabuleiro a situa√ß√£o inicial √© a posi√ß√£o das pe√ßas antes do in√≠cio do jogo e a situa√ß√£o final √© um estado que caracterize o encerramento do jogo, quer com a vit√≥ria de algum dos oponentes, quer com o empate.</li>
</ol>

Em um jogo de xadrez isso pode ser caracterizado tanto por um ‚Äúcheque mate‚Äù (vit√≥ria) quanto por um ‚Äúafogamento do rei (empate)‚Äù. Naturalmente existem muitas configura√ß√µes de ‚Äúcheque mate‚Äù, mas o importante √© que esse estado pode ser caracterizado e reconhecido. Al√©m de jogos de tabuleiro muitos outros problemas possuem essas caracter√≠sticas. 

Uma <em>classe importante</em> deles, que constituem uma das principais aplica√ß√µes pr√°ticas para as t√©cnicas que estudaremos a seguir, s√£o os problemas de <em>roteamento</em> em geral.

<blockquote>Os <b>Sistemas de Produ√ß√£o</b> se caracterizam como sendo possuidores de uma <b>base de estados, um conjunto de operadores e uma estrat√©gia de controle</b>.</blockquote>

A <b>bases de estados</b> √© o conjunto de configura√ß√µes que o problema pode assumir.

Os <b>operadores</b> executam <em>transforma√ß√µes na base de estados</em>, ou seja, <em>levam o problema de um estado a outro</em>. Resolver o problema √©, na verdade, determinar a <em>sequ√™ncia de operadores</em> que deve ser aplicada a partir do <em>estado inicial</em>, de forma a atingir <em>um dos estados finais</em>. 

Se pudermos escolher entre diversos operadores em uma determinada situa√ß√£o, ent√£o precisamos de uma <b>estrat√©gia de controle</b>.

<h4>O sistema basicamente computa:</h4>
<pre><b>Estado &larr; estado inicial</b></pre>

<h4>Enquanto n√£o for satisfeita uma condi√ß√£o de t√©rmino: Selecione um operador R</h4>
<pre><b>Novo estado &larr; R (estado atual)</b></pre>

A condi√ß√£o de t√©rmino √© alcan√ßada se foi atingido um estado final, se n√£o h√° mais operadores aplic√°veis ao estado atual ou se n√£o h√° mais recursos computacionais.</p>

<h3>üß∞üÖ∞Ô∏è‚û°Ô∏è Representa√ß√£o dos Sistemas de Produ√ß√£o üÖ±Ô∏è‚û°Ô∏èü¶æ</h3>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100785707-cc235500-33ef-11eb-88f5-0de1f2fbd3c8.jpg"/></div>
<p align="center"><em><strong>figura 1.1:</strong> Grafo</em></p>
<blockquote>√â poss√≠vel representar um <i>Sistema de Produ√ß√£o</i> atrav√©s de <b>Grafos de Estado</b>.</blockquote>
<p>Os <b>grafos</b> s√£o constitu√≠dos por <b>conjuntos de v√©rtices e de arestas</b>. √â poss√≠vel representar graficamente este conceito. 

Por exemplo, um <em>grafo</em> <b>G</b> com <em>v√©rtices</em> <b>V</b> = {a, b, c} e <em>arestas</em> <b>A</b> = ((a, b), (a, c)), pode ser representado graficamente como na figura.</p>

<p>Em um <strong>grafo de estados</strong>, cada v√©rtice representa um estado e cada aresta a aplica√ß√£o de um operador que causa a mudan√ßa de estado.</p>
  
Vamos apresentar um exemplo que pode ser representado como um grafo de estados e √© conhecido como o problema dos <b>jarros d‚Äô√°gua</b>:

<h3>2. Exemplo: üß∞üè∫ Jarros d'√°gua üè∫ü¶æ</h3>
<div align="center"><img src="https://media.istockphoto.com/vectors/ancient-pottery-vase-jar-amphora-made-in-cartoon-flat-style-vector-id809864684?k=6&m=809864684&s=170667a&w=0&h=LIzEbFmYisGVDMypFKZVhgcoRqDthflZqwLoBn9T1PA=" height="270" title="Jar A"/><img src="https://media.istockphoto.com/vectors/ancient-pottery-vase-jar-amphora-made-in-cartoon-flat-style-vector-id809864684?k=6&m=809864684&s=170667a&w=0&h=LIzEbFmYisGVDMypFKZVhgcoRqDthflZqwLoBn9T1PA=" height=270" title="Jar B"/></div>
<p>Considere <b>dois jarros opacos</b>, nos quais n√£o √© poss√≠vel observar o conte√∫do. Um <strong>jarro A</strong> tem capacidade para 4 litros e um <strong>jarro B</strong> tem capacidade para 3 litros. Queremos colocar exatamente dois litros de √°gua no <strong>jarro A</strong>. Para tanto, temos as seguintes opera√ß√µes dispon√≠veis: <em>encher</em> totalmente um dos jarros; <em>esvaziar</em> totalmente um dos jarros; e, <em>passar</em> o conte√∫do de um jarro para o outro.<br>

Primeiramente, √© preciso arrumar uma representa√ß√£o para o problema, pois somente assim ser√° poss√≠vel caracterizar e reconhecer os estados do problema. Cada problema pode ter uma representa√ß√£o distinta. O estado de uma partida de xadrez, por exemplo, pode ser uma </em>foto do tabuleiro ou uma descri√ß√£o textual das posi√ß√µes das pe√ßas</em>. Devemos escolher a representa√ß√£o mais simples poss√≠vel. Para este problema, o que caracteriza cada estado √© a <em>quantidade de √°gua em cada jarro</em>. Portanto, pode-se criar uma representa√ß√£o que seja um par de n√∫meros, onde o primeiro n√∫mero representa a quantidade de litros de √°gua no jarro A e o segundo a quantidade no jarro B. Assim, por exemplo, (2, 3) indica que h√° 2 litros no jarro A e 3 litros no jarro B.<br>

As opera√ß√µes poss√≠veis de realizar com os jarros constituem as arestas do grafo e, para esse caso, podem ser assim listadas e nomeadas:
<ul>
  <li><b>R1</b> ‚Äì encher o jarro A</li>
  <li><b>R2</b> ‚Äì encher o jarro B</li>
  <li><b>R3</b> ‚Äì esvaziar o jarro A</li>
  <li><b>R4</b> ‚Äì esvaziar o jarro B</li>
  <li><b>R5</b> ‚Äì passar a √°gua do jarro A para o jarro B</li>
  <li><b>R6</b> ‚Äì passar a √°gua do jarro B para o jarro A</li>
</ul>
Inicialmente os jarros est√£o vazios, assim, o estado inicial √© (0, 0). O que objetivamos √© colocar 2 litros no jarro A, portanto, nos interessa alcan√ßar um estado (2, x), onde x √© um valor qualquer. Um grafo, com algumas das poss√≠veis transi√ß√µes, teria a forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100782443-308fe580-33eb-11eb-9846-fd2a0ef91e62.jpg"/></div>
<p align="center"><em><strong>Figura 1.2:</strong> Um grafo com alguns estados e transi√ß√µes do problema das jarras.</em></p>
<blockquote><strong>‚ö†Ô∏è Aten√ß√£o!</strong> Em um <b>grafo de estados</b> pode haver ciclos de forma que opera√ß√µes sucessivas causem retorno a um estado anterior. Essa situa√ß√£o √© indesejada, como indicado na parte mais de baixo da figura 1.2, na qual a aplica√ß√£o sucessiva dos operadores R1 e R3 causou o retorno ao estado inicial. </blockquote>
<h2>üß∞üîé Defini√ß√£o de uma estrat√©gia ou m√©todo de busca üîçü¶æ</h2>
<p>O objetivo em um <em>Sistema de Produ√ß√£o</em> √© obter uma sequ√™ncia de operadores que levem um problema do estado inicial a um estado final. A forma sistem√°tica de percorrer o grafo √† procura desta seq√º√™ncia, √© chamada de <b>M√©todo ou Estrat√©gia de Busca</b>. Um M√©todo de Busca constr√≥i uma <b>√Årvore de Busca</b>, na qual a raiz √© o estado inicial e os n√≥s filhos s√£o obtidos pela aplica√ß√£o sucessiva dos operadores.
<div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Breadth-First-Search-Algorithm.gif/250px-Breadth-First-Search-Algorithm.gif"/></div>
Cada estado s√≥ deve aparecer uma vez na √°rvore, de forma que, caso a aplica√ß√£o de um operador sobre um determinado estado leve a outro estado que j√° est√° na √°rvore, ent√£o este novo estado deve ser descartado (n√£o deve ser inclu√≠do na √°rvore). Isto equivale a dizer que este operador n√£o √© aplic√°vel a este estado neste ramo especifico da √°rvore.</p>

# üîéüìó S√≠ntese do Cap√≠tulo 1 üìóüîç
<blockquote></blockquote>
<hr>
<h1>Cap 02: üîé Descri√ß√£o das estrat√©gias de busca em profundidade üå≥</h1>
<p>A estrat√©gia mais simples poss√≠vel √© a <b>busca em profundidade</b>. Este m√©todo procura uma solu√ß√£o qualquer (que n√£o √© garantidamente a melhor) e encontra-a ou n√£o (o m√©todo n√£o garante que uma solu√ß√£o ser√° encontrada). 

A estrat√©gia consiste em expandir os estados a partir do estado inicial, aplicando qualquer um dos poss√≠veis operadores aplic√°veis √†quele estado. A escolha do operador pode ser aleat√≥ria ou seguir uma sequ√™ncia arbitr√°ria de testes de possibilidade de aplica√ß√£o dos operadores. Caso n√£o haja operadores poss√≠veis de aplicar ou caso todos os estados gerados j√° constem da √°rvore, o m√©todo fracassa. O m√©todo obt√©m sucesso apenas se atinge um estado final.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100808560-22ee5600-3413-11eb-8ded-c4870cb10fc2.jpg"/></div>
<p align="center"><em><strong>Figura 1.3:</strong> Uma busca em profundidade com backtracking.</em></p>
<p>Existe ainda uma altera√ß√£o que melhora a busca em profundidade. Neste m√©todo, quando o algoritmo fracassa em atingir m estado final, de acordo com os crit√©rios do m√©todo irrevog√°vel, volta-se para o n√≥ pai e escolhe-se outro operador. Caso n√£o seja poss√≠vel escolher outro operador para este n√≥, volta-se mais um n√≠vel, repetindo-se o processo at√© que seja atingido o n√≥ raiz. 

Por causa da volta ao n√≥ pai, este m√©todo tamb√©m √© conhecido como <b>backtracking</b>. Agindo desta forma, o algoritmo garante que, caso haja alguma solu√ß√£o, ela ser√° encontrada, j√° que todos os caminhos ser√£o investigados (a busca √© exaustiva). Veja uma ilustra√ß√£o da estrat√©gia no gr√°fico da figura 1.3.
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100810014-3fd85880-3416-11eb-9707-9889dc5aa113.jpg"/></div>
<p align="center"><em><strong>Figura 1.4:</strong> Uma busca em largura.</em></p>

<p>Neste m√©todo, ao inv√©s de escolhermos um operador para ser aplicado em um estado, geramos um novo estado e repetirmos o processo sucessivamente. Assim, o que se faz √© investigar todos os operadores que podem ser aplicados √†quele n√≥ e gerar todos os filhos poss√≠veis. Veja o gr√°fico explicativo da estrat√©gia na figura 1.4.

Este m√©todo sempre encontra o caminho, caso ele exista. Como expande um n√≠vel de cada vez, o m√©todo tamb√©m encontra o caminho mais curto (em n√∫mero de transi√ß√µes) entre a raiz e o estado final. Entretanto, a quantidade de possibilidades avaliadas √© muito grande, o que torna o m√©todo computacionalmente intenso.</p>
<h2>üíµüÖ∞Ô∏è Grafos com custo üÖ±Ô∏èüíµ</h2>
<p>Em alguns tipos de problemas, o caminho de um estado para o pr√≥ximo possui um custo associado. Na pratica, todos os problemas importantes de roteamento possuem custos envolvidos. √â o caso de rotas de transporte de cargas, rotas de distribui√ß√£o de energia el√©trica, rotas de encaminhamento de liga√ß√µes telef√¥nicas, etc. 
</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100899190-52976f80-34a0-11eb-844e-f5026bb7be57.jpg"/></div>
<p align="center"><em><strong>figura 1.5:</strong> Uma configura√ß√£o de grafo com custos</em></p>
<p>Os problemas de encontrar uma rota de um ponto a outro s√£o uma simplifica√ß√£o do problema mais gen√©rico conhecido como o <b>‚Äúproblema do caixeiro viajante‚Äù</b>. No problema do caixeiro viajante original, temos um conjunto de cidades ligadas por estradas, que possuem um <b>custo</b> de liga√ß√£o entre elas e se deseja percorrer todas as cidades ao menor custo poss√≠vel sem repetir nenhuma cidade. A figura exibe uma configura√ß√£o poss√≠vel para essa interliga√ß√£o entre cidades, nas quais as cidades s√£o os <b>v√©rtices do grafo</b> e as liga√ß√µes entre elas s√£o as <b>arestas do grafo</b>.</p>

<p>Na vers√£o mais simplificada, √∫til para um problema de roteamento, o objetivo √© levar o caixeiro de um ponto determinado a outro, ao menor custo poss√≠vel. Se quisermos ir da <em>cidade A</em> at√© a <em>cidade E</em>, temos custos diferentes para cada caminho. Alguns desses custos s√£o:</p>
<ul>
  <li><strong>ABCE</strong> ‚Äì custo: 3+5+8 = 16 </li>
  <li><strong>ACE</strong> ‚Äì custo: 4+8 = 12</li>
  <li><strong>ACDE</strong> ‚Äì custo: 4+7+4 = 15</li>  
  <li><strong>ADE</strong> ‚Äì custo: 6+4 = 10</li>  
</ul>

<h2>üîéüòã Busca gulosa ou busca pelo vizinho mais pr√≥ximo üòçüîç</h2>
<p>Uma estrat√©gia poss√≠vel, embora bastante simpl√≥ria, √© a <b>busca pelo vizinho mais pr√≥ximo</b> ou <b>busca gulosa</b>. Neste caso, escolhemos a cada passo o vizinho ainda n√£o visitado que apresente o menor custo (n√£o devemos repetir cidades, sob o risco de introduzir ciclos, como nas buscas n√£o ponderadas por custos).

Esta estrat√©gia equivale, em algum sentido, √† busca irrevog√°vel, na medida que n√£o garante encontrar um caminho, muito menos o de menor custo. No exemplo anterior, seguindo esta estrat√©gia, a rota escolhida seria ABCDE, o que representaria um custo de 3+5+7+4=19. Como pode ser visto, comparando com o custo apurado para os outros caminhos, este caminho √© pior que todos os acima sugeridos. Logo, esta n√£o √© uma boa estrat√©gia.</p>

<h2>üîé Busca ordenada ou busca pelo caminho de soma m√≠nima (algoritmo de Dijikstra) üßÆ</h2>
<p>Uma outra estrat√©gia √© guardar a soma do custo de cada caminho e procurar a cada passo o caminho que implicar√° na menor soma. Esta estrat√©gia √© parecida com a <b>busca em largura</b> ou <b>algoritmo de Dijikstra</b>. A diferen√ßa √© que, caso um n√≥ deva ser colocado na √°rvore, mas j√° apare√ßa em algum outro caminho (outro ramo diferente deste), deve haver uma compara√ß√£o entre os custos totais destes dois n√≥s e eliminado o de maior custo. Analisemos passo a passo a aplica√ß√£o do algoritmo para o grafo anteriormente apresentado (A‚ÜíE):</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100933996-e3844000-34cc-11eb-8c3a-80653e4aaa9e.jpg"/></div>
<p align="center"><em><strong>Figura 1.6:</strong> Passo 1.</em></p>
<p>Ap√≥s este passo, o custo total de cada caminho √©: AB=3, AC=4 e AD=6. Escolhendo o de menor custo total (AB), expandimos um n√≠vel.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100936388-31e70e00-34d0-11eb-9c8d-5663e7fc567b.jpg"/></div>
<p align="center"><em><strong>Figura 1.7:</strong> Passo 2.</em></p>
<p>Como o novo n√≥ j√° aparece na lista, devemos comparar o custo total desta apari√ß√£o na lista (ABC:3+5=8) com a anterior (AC:=4). Como a anterior possui custo menor, abandonamos esta inser√ß√£o e, como n√£o h√° mais caminhos a analisar para este n√≥ (dizemos que ele est√° fechado), voltamos ao anterior (A) e escolhemos o segundo menor custo dentre os caminhos dispon√≠veis (AC=4).</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100939644-66a99400-34d5-11eb-987e-8015155d0e0c.jpg"/></div>
<p align="center"><em><strong>Figura 1.8:</strong> Passo 3.</em></p>
<p>Note que n√£o foi colocado o n√≥ A porque o caminho ACA n√£o deve ser considerado, pois o n√≥ A j√° est√° neste ramo da √°rvore. O n√≥ B, que j√° aparece em outro ramo, deve ser agora verificado com respeito ao custo total, o que acarreta em comparar o custo do caminho ACB (5+4=9) com o custo do caminho AB (3).

Assim, o caminho ACB deve ser desprezado. Tamb√©m o n√≥ D j√° aparece em outro ramo, de forma que comparando o custo do caminho AD (=6) com o custo do caminho ACD (4+7=11), desprezamos este √∫ltimo. Note tamb√©m que o n√≥ de destino (E) j√° est√° na √°rvore, mas devemos continuar o processamento at√© que todos os n√≥s estejam fechados.</p>

<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100943163-79bf6280-34db-11eb-9c0d-45b64241438c.jpg"/></div>
<p align="center"><em><strong>Figura 1.9:</strong> Passo 4.</em></p>
<p>Tanto o n√≥ E como o n√≥ C j√° aparece na lista. Para o n√≥ C, temos que o caminho ADC tem custo 13 e o caminho AC tem custo 4. Logo, desprezamos C como filho de D.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/101107170-7d70e900-35b0-11eb-81cf-e0a45d0114f1.jpg"/></div>
<p align="center"><em><strong>Figura 1.10:</strong> Passo 5.</em></p>
<p>J√° o caminho ACE tem custo 12, enquanto que o caminho ADE tem custo 10. Desprezamos ACE. Logo:

Agora resta como aberto apenas o n√≥ E. Como ele √© terminal, podemos parar o processo, pois qualquer caminho dele derivado ser√° maior que o caminho at√© ele, haja vista que o custo sempre √© positivo. O caminho encontrado (ADE) √© o caminho √≥timo (de menor custo). Para encontrar este caminho, o algoritmo fechou 2 n√≥s fora do caminho √≥timo (B e C) e 3 no caminho √≥timo (A, D e E).</p>

<h1>Cap 03: üìñ Regras de Produ√ß√£o e Sistemas Especialistas üíº</h1>
<h2>üß† Outras formas de representar conhecimento üí°</h2>
<div align="center"><img src="https://s3.amazonaws.com/ibc-portal/wp-content/uploads/2016/05/22115051/o-que-e-conhecimento.jpg" width="1700"/></div>
<p>Para representar o conhecimento, pelo que acabamos de ver, devemos possuir formas de representar tanto as <em>informa√ß√µes</em>, como os <em>procedimentos</em> (a√ß√µes). Existem v√°rias formas de representa√ß√£o do conhecimento, tais como <b>Redes Sem√¢nticas</b>, <b>Objetos Estruturados</b>, <b>L√≥gica de Primeira Ordem</b> ou <b>Regras de Produ√ß√£o</b>. A forma que estudaremos nesta aula s√£o os <b>sistemas de Regras de Produ√ß√£o</b> (com os quais se constroem aplica√ß√µes chamadas de Sistemas Especialistas).

Para que possamos compreend√™-los, √© necess√°rio entender com quais <em>entidades</em> precisamos lidar. Fundamentalmente, podemos falar em duas entidades: os <b>fatos</b> (As verdades ou informa√ß√µes que possu√≠mos sobre um determinado contexto) e a <b>representa√ß√£o dos conhecimentos</b> (Formalismo simb√≥lico que permite representar e manipular o conhecimento em¬† um determinado contexto).

A forma de representa√ß√£o mais comum √© a <b>linguagem natural</b>. Mas podemos empregar tamb√©m a l√≥gica matem√°tica como formalismo representacional. Considere o exemplo abaixo:</p>

### Exemplo: üß†üê∫ Cachorro Thor ü¶¥üí°
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>1 - Thor √© um cachorro</strong></p>
<p>Este fato pode ser representado em um formalismo l√≥gico como:
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>2 - cachorro Thor</strong></p>
<p>Se tivermos um formalismo para representar que todos os cachorros tem rabo, poder√≠amos escrever:</p>
<p align="center"><strong>3-</strong><code>‚àÄx:cachorro(x)‚áætem-rabo(x)</code></p>
<p>&nbsp;</p>
<p>Usando mecanismos de dedu√ß√£o l√≥gica, poder√≠amos concluir:</p>
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>4 - Tem-rabo (Thor)</strong></p>
<p>Que em linguagem natural equivale a:</p>
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>5 - Thor tem rabo</strong></p>
<p>Este novo fato, pode ser considerado agora, justamente com os demais conhecimentos existentes para produzir novas infer√™ncias, ou seja, gerar novos fatos.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/101213527-47d40a80-3659-11eb-8faa-86a53413755a.jpg"/></div>
<p>Se esta gera√ß√£o tiver uma orienta√ß√£o adequada, poderemos produzir fatos que sejam relevantes em um determinado contexto, ou seja, poderemos encontrar as respostas que objetivamos.</p>

<h2>üìñ Regras de Produ√ß√£o üíº</h2>
<div align="center"><img src="https://endoscopiaterapeutica.com.br/wp-content/uploads/2018/10/333333333333-2006x760.png" width="1700"/></div>

<p>Outra forma de representar o conhecimento √© atrav√©s de <b>regras</b>.

<b>Sistemas baseados em regras</b> foram bastantes populares no in√≠cio das pesquisas com IA e ainda tem larga utiliza√ß√£o para modelar regras de neg√≥cio de aplica√ß√µes especializadas em uma determinada √°rea. Tais conhecimentos s√£o conhecidos como <b>Sistemas Especialistas</b>. As regras s√£o uma forma de representa√ß√£o do conhecimento bastante pr√≥xima da forma humana de express√°-lo.

Por exemplo, conhecimento como os abaixo expressos, podem ser f√°cil e naturalmente postos em formas de regras:
<ul>
  <li>Se a temperatura √© maior que 38 graus, o paciente tem febre.</li>
  <li>Se o paciente tem febre h√° mais de 3 dias, o paciente tem uma infec√ß√£o.</li> 
  <li>Se h√° tens√£o na entrada da fonte e n√£o h√° tens√£o na sa√≠da da fonte, ent√£o o transformador est√° queimado.</li>   
</ul>
Uma regra √© formada por uma <em>premissa simples ou composta</em> (usando operadores l√≥gicos) e uma ou mais conclus√µes que s√£o acionadas quando as premissas s√£o verdadeiras. As premissas/conclus√µes s√£o tamb√©m chamadas de situa√ß√£o/a√ß√£o ou ainda de antecedente/consequente das regras. Os <b>sistemas baseados em regras</b> usam infer√™ncia <b>Modus Pones</b>. Assim, dado que o fato A √© verdadeiro e a implica√ß√£o A¬ÆB √© verdadeira, conclui-se que o fato B √© verdadeiro. Os sistemas que usam esta t√©cnica de representa√ß√£o empregam t√©cnicas de busca por regras e infer√™ncia de novos fatos, de forma a encontrar os fatos que tenham sido definidos como objetivos. A ideia √© encontrar um caminho entre os fatos e conhecimentos que se tem e os fatos que se deseja descobrir.</p>
<p>Por exemplo, considere que temos os seguintes conhecimentos:</p>
<ul>
  <li><b>Regra 1:</b> Se a temperatura ambiente est√° acima de 35 graus. Ent√£o o tempo est√° quente.</li>
  <li><b>Regra 2:</b> Se a umidade relativa do ar √© maior que 75%. Ent√£o a atmosfera est√° √∫mida.</li>
  <li><b>Regra 3:</b> Se o tempo est√° quente e a atmosfera est√° √∫mida.</li>
</ul>
<p>Ent√£o √© prov√°vel que se formem tempestades. Considere ainda que conhecemos os seguintes fatos:</p>
<ul>
  <li><b>Fato 1:</b> A temperatura ambiente √© de 37 graus.</li>
  <li><b>Fato 2:</b> A umidade relativa do ar √© de 81%.</li>
</ul>
<p>As regras 1 e 2 podem, a partir deste fatos, concluir novos fatos:
<ul>
  <li><b>Fato 3:</b> O tempo est√° quente (da regra 1).</li>
  <li><b>Fato 4:</b> A atmosfera est√° √∫mida (da regra 2).</li>
</ul>
<p>Os fatos 3 e 4 satisfazem as premissas da regra 3, levando a outro fato:</p>
<ul>
  <li><b>Fato 5:</b> √â prov√°vel que se formem tempestades.</li>
</ul>

## ‚ôüÔ∏è Estrat√©gias de infer√™ncia üì§
<p>A forma como percorremos as regras, produzindo as infer√™ncias, isto √©, a escolha de quais regras examinar e ativar, pode obedecer a duas abordagens b√°sicas:</p>

### ‚ôüÔ∏è Estrat√©gia dirigida a dados üé≤
<p>Na estrat√©gia dirigida a dados (<b>forward chain</b>), acionam-se todas as regras que possam ser acionadas a partir dos dados (fatos) conhecidos.</p>

### ‚ôüÔ∏è Estrat√©gia dirigida a objetivos üìâ
<p>Na estrat√©gia dirigida a objetivos (<b>backward chain</b>), aciona-se somente as regras que possuam na conclus√£o algum dos objetivos que procuramos. Caso a premissa da regra que desejamos acionar seja desconhecida, estabelecemos esta premissa como o novo objetivo e passamos a buscar regras que a contenha na parte da conclus√£o. Assim, o objetivo original √© provisoriamente abandonado e ser√° retomado (atrav√©s do acionamento da regra abandonada) quando a premissa necess√°ria √† obten√ß√£o do objetivo original tenha sido encontrada. O procedimento √© recorrente, isto √©, os objetivos s√£o provisoriamente abandonados tantas vezes quanta se fa√ßa necess√°rio, formando uma cadeia de busca para tr√°s (backward chain).</p>

<p>Considere, por exemplo, que temos a seguinte base de conhecimentos:</p>
<ul>
  <li><b>Regra 1:</b> Se a taxa de juros √© baixa. Ent√£o a bolsa de valores est√° em alta.</li>
  <li><b>Regra 2:</b> Se a taxa de juros √© alta. Ent√£o a bolsa de valores est√° em baixa.</li>
  <li><b>Regra 3:</b> Se a cota√ß√£o do D√≥lar est√° baixa. Ent√£o a taxa de juros √© alta.</li>
  <li><b>Regra 4:</b> Se a cota√ß√£o do D√≥lar est√° alta. Ent√£o a taxa de juros √© baixa.</li>  
</ul>
<p>Considere tamb√©m que conhecemos o seguinte fato:
  Fato 1: a cota√ß√£o do D√≥lar est√° baixa.
  O que desejamos saber √©: "Qual a tend√™ncia da bolsa de valores?"</p>

![Sem T√≠tulo-1](https://user-images.githubusercontent.com/61624336/101846230-4d38c580-3b2f-11eb-8dab-cd610df6415a.jpg)
<div align="center"><em><strong>Figura 1:</strong> Estrat√©gia de busca orientada a dados</em></div></br>

<p>Onde as regras com c√≠rculos ser√£o acionadas, porque as premissas assim o permitem, enquanto que as demais ser√£o apenas investigadas. Se a busca for com a abordagem orientada a objetivos, teremos a cadeia de investiga√ß√£o e acionamento de regras da figura 2.</p>

![Qualquer coisa](https://user-images.githubusercontent.com/61624336/101947441-45306280-3bcf-11eb-9af5-fa5d985e2b92.jpg)
<div align="center"><em><strong>Figura 2:</strong> Estrat√©gia de busca orientada a objetivos</em></div></br>
<p>Do primeiro para o segundo passo, o objetivo seria trocado de "bolsa de valores" para "taxa de juros" e iniciar-se-ia a busca por este novo objetivo. Quando ele fosse encontrado (ap√≥s o acionamento da regra 3), retornar-se-ia √† regra abandonada (regra 1) para buscar novamente pelo objetivo original, que seria encontrado ap√≥s o acionamento da regra 2.
 
O que acontece quando n√£o √© mais poss√≠vel encontrar regras que gerem o conhecimento objetivado, no esquema de backward chain ou n√£o √© mais poss√≠vel gerar novos conhecimentos no esquema forward chain? Bem, neste caso ocorre o mesmo que quando se vai a uma consulta m√©dica e somente com as informa√ß√µes relatadas e o seu conhecimento, o m√©dico n√£o √© capaz ainda de produzir um diagn√≥stico. Ele precisa agregar novos conhecimentos vindo de fora do sistema. Em uma consulta isto pode representar outras perguntas ao paciente ou a requisi√ß√£o de exames complementares. Em um sistema especialista montado a partir de regras de produ√ß√£o, a agrega√ß√£o de novos conhecimentos que n√£o sejam poss√≠veis de deduzir a partir das regras existentes, geralmente se d√° atrav√©s de perguntas que se faz ao usu√°rio sobre valores das vari√°veis que sejam importantes na cadeia de conhecimento necess√°ria √† resolu√ß√£o do problema que se objetiva.</p>

## ‚ôüÔ∏è Estrat√©gias de infer√™ncia üì§
<p>A evolu√ß√£o na elabora√ß√£o de sistemas especialistas com est√≥rias de sucesso levou os projetistas a separar os sistemas em tr√™s partes, de forma a facilitar a elabora√ß√£o de novos sistemas:</p>

![Sem T√≠tulo-1](https://user-images.githubusercontent.com/61624336/101953638-71e97780-3bd9-11eb-9eca-1bea5f45494f.jpg)

<p>Esta estrat√©gia acabou gerando o aparecimento de ambientes de desenvolvimento de sistemas especialista em que h√° algum tipo de editor e sintaxe para se editar a base de conhecimentos e estabelecer os fatos, acoplado a um motor de infer√™ncias para realizar as buscas.

Tais ambientes, denominados de Shells de Sistemas Especialistas, permitem que o usu√°rio desenvolva sua pr√≥pria base de conhecimentos, de uma forma mais f√°cil e r√°pida. Alguns destes sistemas possuem ainda tradutores de c√≥digo para alguma linguagem procedimental (C, por exemplo), permitindo que o sistema, ap√≥s ter sido depurado, seja integrado com o restante do c√≥digo que tenha sido desenvolvido de forma tradicional./p>

## ü§î Lidando com incertezas ü§®
<ol>
  <li>Muitas das decis√µes que tomamos, s√£o baseadas em algum c√°lculo da probabilidade de acerto, dadas as incertezas sobre os fatos conhecidos. Assim, um m√©dico √© capaz de diagnosticar mesmo sem ter certeza sobre os sintomas relatados pelo paciente, ou das taxas reportadas pelos exames. Da mesma forma, um analista financeiro √© capaz de tomar decis√µes com boas perspectivasde acerto, mesmo diante das incertezas e conflitos dos indicadores do mercado financeiro. Esta capacidade inata do ser humano, est√° associada a algum tipo de c√°lculo de probabilidades.</li>
  <li>Entretanto, implementar c√°lculos estat√≠sticos a partir dos princ√≠pios Bayesianos de probabilidade, torna os sistemas especialistas dif√≠ceis de especificar, na medida em que tratamentos rigorosamente matem√°ticos de probabilidade utilizam informa√ß√µes nem sempre dispon√≠veis ou simplifica√ß√µes que n√£o s√£o claramente justific√°veis em aplica√ß√µes pr√°ticas. Assim, foram constru√≠das alternativas que tamb√©m lidam com confiabilidade das afirmativas, embora em uma base menos rigorosa e ligada basicamente √† teoria dos conjuntos.</li>
  <li>Na maioria dos sistemas, para cada afirmativa √© poss√≠vel usar um fator de confian√ßa. Este fator √© um n√∫mero entre 0% e 100% que est√° relacionado √† expectativa de que aquela afirmativa seja verdadeira. A partir destes valores, se estabelece um limite (em geral 50%, mas que frequentemente pode ser mudado nas shells), para que as afirmativas sejam consideradas verdadeiras ou falsas. Assim, se temos uma vari√°vel Tempo que possui o valor Bom com um grau de confian√ßa 55%, a regra: Se Tempo = Bom ent√£o...., ser√° ativada assim que seja examinada, dado que o fator de confian√ßa do valor Bom √© maior que 50%. Caso o fator de confian√ßa fosse 43%, a regra n√£o seria ativada, pois o valor √© menor que 50% e a premissa seria considerada Falsa.</li>
</ol>
<p>Os c√°lculos com os fatores de confian√ßa envolvem os operadores de implica√ß√£o (ENT√ÉO), conjun√ß√£o (E) e disjun√ß√£o (OU), da seguinte forma:</p>
<table>
  <tr>
    <td>Para opera√ß√µes de implica√ß√£o</td>
    <td>Para opera√ß√µes de conjun√ß√£o</td>
    <td>Para opera√ß√µes de disjun√ß√£o</td>
  </tr>
    <tr>
    <td>O grau de confian√ßa da premissa √© multiplicado pelo grau de confian√ßa da conclus√£o;</td>
    <td>O grau de confian√ßa de todas as premissas √© multiplicado para obter o grau de confian√ßa da premissa composta;</td>
    <td>O grau de confian√ßa de todas as premissas √© somado e o resultado √© subtra√≠do da multiplica√ß√£o dos mesmos graus de confian√ßa, para obter o grau de confian√ßa da premissa composta.</td>
  </tr>
</table>
<p>Por exemplo, suponha que conhecemos os fatos A, C e E com confiabilidade de 90% e temos as seguintes regras:</p>
<ul>
  <li>Se A Ent√£o B (confiabilidade 70%)</li>
  <li>Se B e C ent√£o D (confiabilidade 100%)</li>
  <li>Se D ou E ent√£o F (confiabilidade 40%)</li>
  <li>Se F ent√£o G (confiabilidade 100%)</li>
</ul>
<ol>
  <li>A primeira regra leva a: CF(A) * CF(conclus√£o) = 0,9 * 0,7 = 0,63 = CF(B)</li>
  <li>A Segunda regra leva a: CF(B) * CF(C) = 0,63 * 0,9 = 0,567 * 1 = CF(D)</li>
<li>A terceira regra leva a: CF(D) + CF(E) - CF(D) * CF(E) = 0,567 + 0,9 - 0,567 * 0,9 =¬† 1,467 - 0,51 = 0,957 * 0.4 = 0,383 = CF(F)</li>
  <li>A quarta regra n√£o ser√° acionada porque CF(F) = 0,383 < 0,50</li>
</ol>
<p>Quando diferentes regras levam a diferentes graus de confian√ßa para uma mesma vari√°vel, em geral √© tamb√©m aplicado o c√°lculo da disjun√ß√£o para estes dois valores, como no caso do operador OU. Assim, para o exemplo acima, caso tiv√©ssemos uma regra que fosse:

Se B ent√£o F (confiabilidade 90%)
Ter√≠amos: CF(B) * 0,90 = 0,63 * 0,90 = 0,567 = CF(F)
Como a CF(F) anterior era 0,383, a nova CF(F) = 0,567 + 0,383 - 0,567 * 0,383 = 0,95 - 0,217 = 0,733 = CF(F)</p>
<p>Alguns sistemas tratam as opera√ß√µes com fatores de confian√ßa de uma forma alternativa, utilizando fun√ß√µes de m√°ximo e m√≠nimo. Assim as opera√ß√µes de conjun√ß√£o t√™m seu fator de confian√ßa resultante calculado como o m√≠nimo entre os valores de confian√ßa das diversas premissas. J√° a opera√ß√£o de disjun√ß√£o leva a um fator de confian√ßa igual ao m√°ximo dos fatores das premissas envolvidas. A opera√ß√£o de implica√ß√£o, nesta forma de c√°lculo, geralmente tamb√©m √© feita atrav√©s do produto entre o fator de confian√ßa resultante da premissa e o fator de confian√ßa atribu√≠do √† implica√ß√£o. Se fosse realizado este tipo de c√°lculo no exemplo acima, a regra 2 levaria a um grau de confian√ßa para D de: CF(D) = Min (0,63 , 0,9) * 1 = 0,63 = CF(D). J√° a regra 3 levaria a: CF(F) = Max (0,63 , 0,9) * 0,4 = 0,9 * 0,4 = 0,36 = CF(F). 

Em qualquer caso, a atribui√ß√£o dos fatores de confian√ßa relativos √†s implica√ß√µes √© de responsabilidade do especialista que definiu a regra e, provavelmente, √© oriundo da experi√™ncia na aplica√ß√£o do conhecimento formal aprendido em casos de uso do passado.</p>

# Cap 04: üîÄ L√≥gica Nebulosa (Fuzzy) e Sistemas baseados em regras Fuzzy üíπ
<p>A <b>L√≥gica Fuzzy</b> √© baseada na teoria dos conjuntos fuzzy. Tradicionalmente, uma proposi√ß√£o l√≥gica tem dois extremos: ou √© completamente verdadeiro ou √© completamente falso. </p>
<img src="https://emgotas.files.wordpress.com/2016/11/lc3b3gica-fuzzy2.jpg?w=840" width="1070"/>

## üîÄ Conjuntos Nebulosos (Conjuntos Fuzzy) üåÅ
<p>Um <b>conjunto nebuloso</b>, tamb√©m chamado de <b>conjunto fuzzy</b>, √© uma fun√ß√£o que permite a entrada de um valor escalar e fornece como sa√≠da um n√∫mero entre zero e um, que representa o grau de pertin√™ncia (¬µ) da entrada ao conjunto fuzzy. Por exemplo, podemos definir o conjunto de pessoas altas com dois diferentes tipos de fun√ß√£o ilustrados na figura.</p>
<div align="center"><em><strong>Conjunto crisp e conjunto fuzzy</strong></em></div></br>
<img src="https://user-images.githubusercontent.com/61624336/101990623-a49d7980-3c86-11eb-8208-0eddbb6a00fc.jpg"/>
<p>Para este caso, na fun√ß√£o fuzzy, pessoas com altura menor que 1,70m possuem grau de pertin√™ncia 0 em rela√ß√£o ao conjunto de pessoas altas, ou seja, n√£o s√£o definitivamente altas. Pessoas com altura maior que 1,90m possuem grau de pertin√™ncia 1 em rela√ß√£o ao conjunto de pessoas altas, ou seja, s√£o definitivamente altas. J√° pessoas com altura entre 1,70m e 1,90m possuem algum grau de pertin√™ncia (0< ¬µ <1) ao conjunto de pessoas altas. Outro exemplo est√° na figura.</p>

<div align="center"><em><strong>Conjunto fuzzy</strong></em></div></br>

![Sem T√≠tulo-1](https://user-images.githubusercontent.com/61624336/101994207-6a8ca180-3c9f-11eb-9b82-5e8d47ac5e90.jpg)

<p>Para calcular o grau de pertin√™ncia de uma vari√°vel a um conjunto fuzzy, pode-se utilizar qualquer fun√ß√£o que associe o dom√≠nio da vari√°vel que se deseja fuzzificar com a imagem do intervalo [0,1] correspondente ao grau de pertin√™ncia da vari√°vel do dom√≠nio ao conjunto modelado pela fun√ß√£o fuzzy. O formato das fun√ß√µes de pertin√™ncia pode variar bastante. Algumas das principais fun√ß√µes utilizadas na literatura s√£o:</p>

![gif](https://user-images.githubusercontent.com/61624336/101996380-a67c3280-3cb0-11eb-8d75-468a13602a40.gif)

## üíº Sistemas de l√≥gica Fuzzy üíπ
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102001311-73956700-3ccf-11eb-82c7-1fafe7858a55.jpg"/></div>
<p>Um <b>sistema fuzzy</b> lida com conjuntos fuzzy para fazer as tarefas de fuzzyfica√ß√£o dos valores escalares do mundo real, para que possam ser manipulados como entidades lingu√≠sticas (Pessoas altas no caso da figura.) e, ap√≥s a aplica√ß√£o de <b>regras</b> de infer√™ncia que s√£o expressas com essas entidades lingu√≠sticas, mas lidam na verdade com os valores de pertin√™ncia, produzir atrav√©s de um processo chamado <b>defuzzyfica√ß√£o</b> os valores escalares que se apliquem √† sa√≠da para o mundo real. 
O modelo pode ser representado como na figura.</p>
<blockquote>As regras combinam vari√°veis lingu√≠sticas (quente, alto, barato, etc.), quantificadores (muito, pouco, extremamente, etc.), operadores l√≥gicos (E, OU, N√ÉO) e de implica√ß√£o (SE, ENT√ÉO).
Por exemplo:

SE temperatura √© muito quente E fluxo √© baixo ENT√ÉO gire a torneira muito √† direita.

SE temperatura √© morna E fluxo √© m√©dio ENT√ÉO gire a torneira um pouco √† esquerda.</blockquote>
<blockquote>A defuzzifica√ß√£o combina os valores produzidos pelas diversas regras que tenham sido acionadas para uma determinada entrada, produzindo, a partir da combina√ß√£o dos conjuntos fuzzy, uma sa√≠da escalar adequada.</blockquote>

## üíπ Nomenclatura üíπ
<p><b>Dom√≠nio do conjunto fuzzy</b> √© o universo de valores poss√≠veis para um determinado conjunto. Para o conjunto fuzzy de pessoas altas, visto anteriormente o dom√≠nio √© aberto (de 0 a +‚àû). J√° para o conjunto de pessoas de meia idade o dom√≠nio √© fechado (20 a 70). 

Suporte do conjunto √© o subconjunto do dom√≠nio para o qual o grau de pertin√™ncia √© maior que zero. Para o conjunto de pessoas de meia idade, √© o intervalo de 30 a 60. </p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102002391-df310180-3cda-11eb-801c-700d7930597d.jpg"/></div>
<p><b>Conjunto Singleton</b> √© um conjunto fuzzy em que o suporte √© um √∫nico ponto do dom√≠nio. Por exemplo, o conjunto de notas ideais em um dom√≠nio de 0 a 10, pode ser um conjunto Singleton em que apenas a nota 10 possui ¬µ =1 e as demais possuem ¬µ =0.
  O <b>Universo do discurso</b> √© o espa√ßo completo de varia√ß√£o dos valores de pertin√™ncia para uma determinada vari√°vel. Por exemplo, para uma vari√°vel temperatura assim modelada:

O universo do discurso √© de 100 a 360 graus.</p>

<p>As opera√ß√µes com os conjuntos Fuzzy visam encontrar o grau de veracidade das afirmativas que fazem parte dos antecedentes das regras. Essas opera√ß√µes b√°sicas (Uni√£o, Interse√ß√£o, Complemento) s√£o realizadas com o grau de pertin√™ncia (¬µ) de um valor ao conjunto. Para saber se um valor pertence ao conjunto Fuzzy, devemos saber se o valor pertence ao Dom√≠nio do conjunto, ao seu Suporte e se est√° acima do limite a-cut.

As opera√ß√µes podem ser aplic√°veis a uma mesma vari√°vel ou vari√°veis distintas. Exemplos para uma vari√°vel:</br>
Se idade √© crian√ßa OU idade √© velho ent√£o risco de gripe √© alto</br>
Se idade N√ÉO √© meia-idade ent√£o risco de infarto √© baixo</br>

Exemplo para duas vari√°veis:</br>
Se temperatura √© alta E press√£o √© baixa ent√£o vaz√£o √© alta</p>

<p>Para a <b>opera√ß√£o de complemento</b> (Ex: Se x N√ÉO √© A ent√£o...), a forma de c√°lculo do antecedente, geralmente √©: 1 - ¬µA(x).</br>
Para a Uni√£o e a interse√ß√£o, existem diferentes formas, propostas por diferentes autores, para realizar as opera√ß√µes, como mostra a tabela a seguir:</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102003141-43a38f00-3ce2-11eb-8ce0-da077f42b9b3.jpg"/></div>

## üìâ Quantificadores üìà
<p>Os <b>quantificadores</b> s√£o termos que modificam os conjuntos Fuzzy originais, a partir de alguma opera√ß√£o matem√°tica feita com os mesmos. Os principais quantificadores s√£o dos seguintes tipos:</p>
<ul>
  <li><b>Intensificador:</b> muito, extremamente, super, hiper.</li>
  <li><b>Atenuador:</b> pouco, levemente, discretamente.</li>  
  <li><b>Aproximador:</b> em torno de, por volta de, aproximadamente.</li>
  <li><b>Restritivo:</b> no m√°ximo, a partir de, n√£o maior que.</li>  
</ul>
<p>Para modelar o calculo da influ√™ncia dos quantificadores de intensifica√ß√£o nos conjuntos Fuzzy originais, podemos usar pot√™ncias inteiras. Ou seja, ¬µintensificador de A = (¬µA)‚Åø. Desta forma, para diferentes valores de n poder√≠amos modelar diferentes quantificadores de intensifica√ß√£o, conforme mostrado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102014842-dff78100-3d36-11eb-9535-5de90e8b9c2f.jpg"/></div>
<p>Por outro lado, para calcular a influ√™ncia dos quantificadores de atenua√ß√£o nos conjuntos Fuzzy, podemos usar pot√™ncias fracion√°rias. Ou seja, ¬µatenuador de A = (¬µA)‚Öü‚Åø. Assim sendo, para diferentes valores de n poder√≠amos modelar diferentes quantificadores de atenua√ß√£o, conforme mostrado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102015052-dae70180-3d37-11eb-84d2-f6ac7411bc90.jpg"/></div>

<div align="center"><h1>Cap 05: üîÄ Fuzzy system building üèóÔ∏è</h1></div>

## üßê Infer√™ncia Fuzzy üîÄ
<p>A <b>infer√™ncia Fuzzy</b> √© uma rela√ß√£o l√≥gica que obedece √† mesma tabela verdade da Implica√ß√£o Modus Ponens da l√≥gica proposicional tradicional (l√≥gica crisp). A diferen√ßa √© que na l√≥gica crisp, a regra √© acionada somente se a premissa for verdadeira e na l√≥gica fuzzy a regra √© acionada quando a premissa possui um grau de pertin√™ncia diferente de zero.

A regra √© uma composi√ß√£o de rela√ß√µes Fuzzy onde a primeira rela√ß√£o √© um conjunto fuzzy (possivelmente resultante de uma opera√ß√£o Fuzzy) e a segunda rela√ß√£o √© de implica√ß√£o.

Exemplo:</br>
SE Homem √© novo ENT√ÉO Homem √© mau motorista.</br>
SE <b>peso √© gordo E idade √© meia idade</b> ENT√ÉO <b>risco √© alto</b>.</p>
<p>Para calcular a rela√ß√£o de implica√ß√£o, a forma mais usada √© a sugerida por Mandani, apesar de existirem outras, propostas por Zadeh, Takagi-Sugeno, Tsukamoto e outros. Mandani prop√µem utilizar o m√≠nimo ou o produto dos graus de pertin√™ncia.</p>
<p>Usando o m√≠nimo: ¬µp‚Üíq (x,y) = min [¬µp(x), ¬µq(y)]</p>
<p>Usando o produto: ¬µp‚Üíq (x,y) = ¬µp(x)*¬µq(y)</p>

<p>O conjunto resultante da implica√ß√£o toma as formas da figura para os casos de infer√™ncia pelo m√≠nimo e pelo produto.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102017160-f1935580-3d43-11eb-9926-6feab9722ab4.jpg"/></div>

## üìñ Combinando regras acionadas üìñ
<p>Caso haja um conjunto de regras e duas ou mais sejam acionadas, pode-se calcular o conjunto resultante da aplica√ß√£o das diferentes regras, utilizando-se o m√©todo do m√°ximo ou o m√©todo da soma dos conjuntos Fuzzy do consequente de cada regra, al√©m de outras op√ß√µes de combina√ß√£o menos usadas. Por exemplo, utilizando-se o m√≠nimo para a implica√ß√£o e o m√°ximo para a composi√ß√£o de duas regras do tipo:</p>
<pre>Se x √© A E y √© B ent√£o z √© C</pre>
<blockquote>üí° <strong>Dica:</strong> Temos o conjunto Fuzzy resultante ilustrado na figura.</blockquote>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102017493-040e8e80-3d46-11eb-9120-9010efc17c5f.jpg"/></div>

## üìà Defuzzyfica√ß√£o üî¢
<p>Um sistema Fuzzy possui entrada(s) escalar(es) e deve ser capaz de produzir uma sa√≠da tamb√©m escalar. Ap√≥s serem realizadas as infer√™ncias com as regras e ap√≥s se haver determinado o conjunto Fuzzy resultante (conjunto Fuzzy de sa√≠da), deve-se encontrar um valor num√©rico (escalar) para a sa√≠da. A este processo chama-se <b>Defuzzyfica√ß√£o</b> do conjunto de sa√≠da.

## üìö M√©todos de Defuzzyfica√ß√£o üìà
<p>Existem m√©todos propostos por diversos autores. Dois dos mais usados s√£o:</p>
<ul>
   <li><b>Centro de √°rea:</b> Calcula o centro de gravidade da √°rea do conjunto e usa o valor deste ponto (figura).</br>
  <div align="center"><img src="https://user-images.githubusercontent.com/61624336/102018118-f78c3500-3d49-11eb-8784-116e6ab5f802.jpg"/></div>
  Um problema √© que o centro da figura √© dif√≠cil de calcular se o universo do discurso n√£o for discreto ou se as fun√ß√µes fuzzy forem complexas.</li>
  <li><b>M√©dia dos m√°ximos:</b> Observa o conjunto Fuzzy de sa√≠da C e determina os valores x de sa√≠da para os quais m C (x) √© m√°ximo, ou seja, pega os valores de m√°ximo de cada conjunto que contribuiu para formar o conjunto C de sa√≠da. Em seguida, calcula a m√©dia destes valores de m√°ximo ponderados pelos graus de pertin√™ncia dos respectivos conjuntos e usa-se este valor de m√©dia como a sa√≠da desejada. 
  <div align="center"><img src="https://user-images.githubusercontent.com/61624336/102018283-29ea6200-3d4b-11eb-9f63-4d73dddbe811.jpg"/></div>
O valor de sa√≠da z √© calculado como: z = (MC1 . ¬µC1 + MC2 . ¬µC2) / (¬µC1 + ¬µC2).</li>
</ul>

## üìö Exemplos de aplica√ß√£o üìà
<p><b>Sistemas fuzzy</b> s√£o muito utilizados em aplica√ß√µes de controle. Algumas destas aplica√ß√µes, podem ser encontradas em uma ferramenta que possui uma vers√£o de demonstra√ß√£o chamada <b>FuzzyTech</b>. Um destes exemplos √© o controle de um guindaste que se movimenta em uma dimens√£o linear e deve posicionar uma determinada carga em uma plataforma. O controle fuzzy envolve o c√°lculo da pot√™ncia a ser aplicada ao motor (positiva ou negativa para movimentar o guindaste nos dois sentidos de dire√ß√£o), a partir das informa√ß√µes de √¢ngulo (em graus) que a carga faz com o eixo vertical e dist√¢ncia (em jardas) que a mesma se encontra da plataforma. A figura ilustra o sistema que se deseja controlar.</p>
<blockquote>üí°<strong>Dica:</strong> Esta figura e as figuras seguintes foram retiradas do aplicativo <a href="https://www.fuzzytech.com/">FuzzyTech</a>.</blockquote>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102020026-68851a00-3d55-11eb-8714-254d767277b5.jpg"/></div>
<p>A vari√°vel de entrada √¢ngulo √© modelada pelos valores lingu√≠sticos pos-big, pos-small, zero, neg-small e neg-big. Seu universo do discurso √© dado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102020222-7b4c1e80-3d56-11eb-96cc-f9d416fe2982.jpg"/></div>
<p>A vari√°vel de entrada dist√¢ncia √© modelada pelos valores lingu√≠sticos neg-close, zero, close, medium e far. Seu universo do discurso √© dado na figura.</div>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102021611-ac7d1c80-3d5f-11eb-93b5-9b03844a6977.jpg"/></div>
<p>A vari√°vel de sa√≠da pot√™ncia √© modelada pelos valores lingu√≠sticos neg-big, neg-me, zero, pos-me e pos-hig. Seu universo do discurso √© dado na figura.</p>

<p>As regras do sistema de controle que calcula a pot√™ncia trabalham com os valores lingu√≠sticos das vari√°veis do modelo e s√£o do seguinte tipo:</p>
¬†
<p>Se DIST√ÇNCIA = far e √ÇNGULO = neg_small</p>
<p>Ent√£o POT√äNCIA = pos_high</p>
<p>Se DIST√ÇNCIA = medium e √ÇNGULO = neg_small</p>
<p>Ent√£o POT√äNCIA = pos_high</p>
<p>Se DIST√ÇNCIA = medium e √ÇNGULO = neg_big</p>
<p>nt√£o POT√äNCIA = pos_medium</p>

<p>Assim, se em um determinado instante, temos valores espec√≠ficos para as vari√°veis de entrada, como por exemplo, dist√¢ncia = 13 jardas e √¢ngulo = -45 graus, diferentes regras podem ser concomitantemente acionadas. 

Para o referido valor de dist√¢ncia (13 jardas), dois conjuntos possuem ¬µ > 0 (observe que a linha vertical que parte do valor 13 corta duas curvas de fun√ß√µes de pertin√™ncia). Ou seja, dist√¢ncia=medium com ¬µ =0,76 e dist√¢ncia=far com ¬µ =0,24. Observe a figura. </p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102022993-3a113a00-3d69-11eb-8968-b9520d728b04.jpg"/></div>
<p>Da mesma forma, para o √¢ngulo (-45 graus), dois conjuntos possuem m>0 (observe que a linha vertical que parte do valor -45 tamb√©m corta duas curvas de fun√ß√µes de pertin√™ncia). Neste caso, √¢ngulo=neg_small com m=0,30 e √¢ngulo=neg_big com m=0,70. Observe a figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102023114-02ef5880-3d6a-11eb-91b4-c3b65731419b.jpg"/></div>
<p>Assim, para a primeira regra, 
¬†
Se DIST√ÇNCIA = far e √ÇNGULO = neg_small</br>
Ent√£o POT√äNCIA = pos_high</br></p>
¬†
<p>Temos, na premissa, ¬µ=0,24 e ¬µ=0,30. Para combinar estes valores com o operador l√≥gico E existem, como vimos, diversos m√©todos. Um dos mais comuns √© tomar o m√≠nimo dos dois valores. Assim, o valor da combina√ß√£o l√≥gica ser√° MIN (0,24; 0,30) = 0,24 e este ser√° o grau de pertin√™ncia da premissa da regra. Usando para a infer√™ncia tamb√©m o operador de m√≠nimo, a conclus√£o da regra ser√° acionada com um grau de pertin√™ncia de, no m√°ximo, ¬µ=0,24. 
Entrando com o valor ¬µ=0,24 no gr√°fico de fun√ß√µes da vari√°vel de sa√≠da pot√™ncia, para o conjunto determinado pela regra (pos_high), temos o resultado da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102025887-90867480-3d79-11eb-925d-e6f6dd91ce48.jpg"/></div>
<p>Da mesma forma, para a segunda regra,
Se DIST√ÇNCIA = medium e √ÇNGULO = neg_small</br>
Ent√£o POT√äNCIA = pos_high</br>
temos uma premissa com MIN(0,76; 0,30) = 0,30. Logo, o gr√°fico da vari√°vel de sa√≠da ter√° a forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102025974-1e625f80-3d7a-11eb-984c-a45f48e16e23.jpg"/></div>
<p>Finalmente, para a terceira regra,</br>
Se DIST√ÇNCIA = medium e √ÇNGULO = neg_big</br>
Ent√£o POT√äNCIA = pos_medium</br>
temos o grau de pertin√™ncia da premissa como MIN(0,76; 0,70) = 0,70. Assim o gr√°fico da vari√°vel de sa√≠da ter√° a forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026364-2e7b3e80-3d7c-11eb-8444-077c299b6bdf.jpg"/></div>
<p>Como resultado da aplica√ß√£o das tr√™s regras, temos a forma da figura:</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026580-6c2c9700-3d7d-11eb-9a8b-37153cfd8d0f.jpg"/></div>
<p>Como as tr√™s regras foram acionadas, temos a uni√£o dos tr√™s conjuntos. Para representar a uni√£o, geralmente utiliza-se o m√°ximo dos conjuntos (Mandani), o que, portanto, resulta na forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026635-c594c600-3d7d-11eb-9610-0c1b0ae2bc28.jpg"/></div>
<p>Finalmente, para que possamos encontrar um valor de sa√≠da para a pot√™ncia (defuzzifica√ß√£o) podemos utilizar v√°rios m√©todos. Achar o centro de massa da figura resultante √© um deles (dif√≠cil de calcular). Outro m√©todo, chamado M√©dia dos M√°ximos, calcula a m√©dia dos valores t√≠picos das fun√ß√µes ativadas (valores de m√°ximo) ponderados pelos graus de pertin√™ncia com que estes conjuntos foram ativados. Assim, para o caso temos o indicado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026753-7307d980-3d7e-11eb-80e6-6df0f31c8249.jpg"/></div>
<p>O valor da vari√°vel de sa√≠da pot√™ncia, para este instante, dados os valores das vari√°veis de entrada (12 jardas e ‚Äì45 graus) e as regras citadas, seria portanto (observe que os valores de m√°ximo de cada conjunto, usados no c√°lculo da m√©dia dos m√°ximos, s√£o os indicados pelas setas na figura anterior):
</br>
M√©dia = (10 x 0,7 + 23,5 x 0,3) / (0,7 + 0,3) = 14,05</br>
</br>
Ou seja, para uma dist√¢ncia de 12 jardas e um √¢ngulo de -45 graus, o controle Fuzzy produz como sa√≠da uma pot√™ncia de 14,05 KW a ser aplicada ao motor do guindaste. Esse valor seria aplicado na planta geraria uma altera√ß√£o da dist√¢ncia e do √¢ngulo da carga, o que realimentaria o controle fuzzy na pr√≥xima itera√ß√£o.</p>
<div align="center"><h1>Cap 06: üë®‚Äç‚öïÔ∏è Evolved Systems and Genetic Algorithms üß¨</h1></div>
<img src="https://www.genengnews.com/wp-content/uploads/2019/05/GettyImages-1084312676.jpg" width="1070"/>
<h2>üòµ O problema de otimiza√ß√£o ü§Ø</h2>
<p>Um <b>problema de otimiza√ß√£o</b> consiste em encontrar, entre as muitas solu√ß√µes poss√≠veis para um problema, aquela ou aquelas que representam a melhor solu√ß√£o. Naturalmente o conceito de melhor se aplica a algum ou a alguns crit√©rios, tais como o custo financeiro, o tempo, a dist√¢ncia, a seguran√ßa ou a qualquer outro aspecto que se deseje otimizar.

Qualquer processo de otimiza√ß√£o pode ser resumido em como encontrar os par√¢metros que minimizam (ou maximizam, depende do problema) uma determinada fun√ß√£o multi parametrizada (de muitos par√¢metros), ou seja, encontrar o MIN ( f( x1, x2, x3,...xn)). 

Todo problema de maximiza√ß√£o pode ser transformado em um problema de minimiza√ß√£o e vice versa. Por exemplo, tomando-se a fun√ß√£o mono-parametrizada y = f(x) = 2-x2, no intervalo (-2<x<2), teremos um √∫nico ponto (x=0) que maximiza a fun√ß√£o.</p>
<p>Entretanto, se multiplicarmos a fun√ß√£o f(x) por -1, calculando ent√£o a fun√ß√£o g(x) = -f(x) = x2 ‚Äì 1, ter√≠amos um √∫nico e mesmo ponto (x=0) que minimiza a fun√ß√£o para o mesmo intervalo. Assim, em geral, podemos estudar otimiza√ß√£o apenas como um problema de minimiza√ß√£o ou apenas como um problema de maximiza√ß√£o, pois o(s) ponto(s) de minimiza√ß√£o da fun√ß√£o e o(s) de maximiza√ß√£o da fun√ß√£o inversa s√£o os mesmos. 

Quando a abordagem escolhida √© estudar os problemas de otimiza√ß√£o como problemas de minimiza√ß√£o, o valor da fun√ß√£o pode ser visto como um ‚Äúcusto‚Äù a ser minimizado.

Mesmo trabalhando com uma <em>fun√ß√£o mono-parametrizada</em>, √© poss√≠vel que esta possua, dentro de um determinado intervalo, v√°rios pontos de m√≠nimos ou m√°ximos relativos, conhecidos como m√≠nimos locais e m√°ximos locais, havendo somente um ponto de m√≠nimo global ou de m√°ximo global no intervalo. Uma fun√ß√£o desse tipo √© chamada de <b>unimodal</b>.</p>
<p>Tomemos por exemplo a fun√ß√£o f(x) = x sen (3 x) no intervalo -5<x<10, cujo gr√°fico encontra-se na figura 1. Sob o ponto de vista de maximiza√ß√£o ela √© unimodal pois, no intervalo considerado, ela possui um ponto de m√°ximo para x = 8,91 no qual f(x) = 8,92.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102034373-a0fc1680-3d9c-11eb-9801-0c14ccd1bd18.jpg"/></div>
<div align="center"><em><strong>Figura 1:</strong> Fun√ß√£o mono-parametrizada unimodal: f(x) = x sen (3 x)</em></div></br>

<p>J√° uma fun√ß√£o multimodal possui mais de um m√°ximo global para um determinado intervalo. Tomemos, por exemplo, a fun√ß√£o f(x) = sen (x/2) + cos (2x)/1,5 no intervalo -14&lt;x&lt;20, vista na figura 2. A fun√ß√£o possui pontos de m√°ximo em x = -9.42, x = 3 e x = 15,71. Nesses pontos temos f(x) = 1,66666..., que vem a ser o valor m√°ximo que a fun√ß√£o atinge nesse intervalo.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102041828-36a0a180-3daf-11eb-939a-373c3d02fe9f.jpg"/></div>
<div align="center"><em><strong>Figura 2:</strong> Fun√ß√£o mono-parametrizada multimodal: f(x) = sen (x/2) + cos (2x)/1,5</em></div></br>
<p>A fun√ß√£o que se deseja otimizar √© conhecida como Fun√ß√£o Objetivo e o intervalo em que se seja buscar uma solu√ß√£o √© o Espa√ßo de Busca. Para a fun√ß√£o da figura 6.2 o espa√ßo de busca por valores de x √© o intervalo entre -14 e 20. 
Os par√¢metros da fun√ß√£o podem ainda estar sujeitos a restri√ß√µes expressas por meio de equa√ß√µes ou inequa√ß√µes, tais como:
Minimizar f(x) = x2 + y2 + 4
sujeito √†s restri√ß√µes de: 2x - 3y < 5 e de: x + y = 7. <br />
Quando a fun√ß√£o objetivo e as fun√ß√µes das restri√ß√µes possuem apenas rela√ß√µes lineares (operadores aritm√©ticos de adi√ß√£o, subtra√ß√£o multiplica√ß√£o e divis√£o), o problema √© de Programa√ß√£o Linear. Caso, entretanto, haja algum outro operador nas fun√ß√µes, tais como exponencia√ß√£o, logaritmos, express√µes trigonom√©tricas ou quaisquer outros operadores n√£o lineares, o problema √© de Programa√ß√£o n√£o Linear.</p>
<p>Os par√¢metros da fun√ß√£o objetivo podem ainda ser <b>cont√≠nuos</b> ou <b>discretos</b>.</p>
<blockquote><b>Par√¢metros cont√≠nuos</b> podem levar a situa√ß√µes onde haja uma quantidade infinita de solu√ß√µes poss√≠veis (combina√ß√µes de diferentes valores para os par√¢metro que otimizam a fun√ß√£o objetivo e n√£o ferem nenhuma restri√ß√£o). </blockquote>
<blockquote><b>Par√¢metros discretos</b> possuem sempre uma quantidade finita de solu√ß√µes, dado que a quantidade de valores discretos em um intervalo √© tamb√©m finita e qualquer solu√ß√£o √© uma combina√ß√£o desses valores. Dentro dos problemas com par√¢metros discretos, uma classe de problemas importante √© a dos que buscam uma sequ√™ncia de espec√≠fica de valores, tais como uma sequencia de tarefas ou uma sequencia de locais a serem visitados. Tais problemas s√£o conhecidos como <b>problemas de Otimiza√ß√£o Combinat√≥ra</b></blockquote>

## üë®‚Äç‚öïÔ∏è Solu√ß√µes para o problema de otimiza√ß√£o üòµ
<p>Existem muitas e diversificadas classes de t√©cnicas aplic√°veis a problemas de otimiza√ß√£o. Algumas naturalmente se aplicam melhor a alguns problemas do que a outros, mas todas t√™m alguma restri√ß√£o. Vamos comentar a seguir algumas dessas classes de solu√ß√µes.</p>
<ol>
  <li>Uma primeira ideia, usando <b>for√ßa bruta computacional</b>, pode ser simplesmente gerar aleatoriamente solu√ß√µes, ou seja, valores aleat√≥rios para os par√¢metros dentro do espa√ßo de busca e testar as solu√ß√µes geradas para cada conjunto de par√¢metros, comparando os resultados dos testes. Esse m√©todo √© conhecido como <b>Busca Aleat√≥ria</b> e sua principal defici√™ncia est√° no grande esfor√ßo computacional necess√°rio a encontrar uma solu√ß√£o satisfat√≥ria, que pode inclusive, dependendo do espa√ßo de busca do problema, virtualmente inviabilizar a obten√ß√£o de uma solu√ß√£o satisfat√≥ria.</li>
  <li>Existem, por outro lado, m√©todos cl√°ssicos, chamados de <b>T√©cnicas Anal√≠ticas</b>, como o m√©todo de Newton-Raphson, que utilizam t√©cnicas exclusivamente matem√°ticas para determinar os pontos de m√°ximo e m√≠nimo das fun√ß√µes. Tais m√©todos se baseiam em geral em t√©cnicas de c√°lculo diferencial, o que exige, por sua vez, que as fun√ß√µes sejam cont√≠nuas e diferenci√°veis no espa√ßo de busca, caracter√≠sticas que muitas vezes n√£o s√£o encontradas em problemas do mundo real. Nessas t√©cnicas pode ainda ser dif√≠cil determinar os pontos de m√°ximo ou m√≠nimo quando as fun√ß√µes possuem muitos par√¢metros e s√£o intensamente multi-modais.</li>
  <li>J√° os m√©todos conhecidos como <b>Subida de Encosta</b>, tais como o m√©todo do Gradiente Descendente ou o m√©todo de Recozimento Simulado procuram em um pequeno espa√ßo de busca em torno de uma solu√ß√£o, buscando localizar a dire√ß√£o em que a fun√ß√£o cresce ou decresce. Tais m√©todos s√£o r√°pidos, por√©m s√£o muito sens√≠veis √† exist√™ncia de m√°ximos ou m√≠nimos locais.</li>
  <li>Os M√©todos Heur√≠sticos, tais como os <b>Algoritmos Gen√©ticos</b>, t√™m como principal caracter√≠stica a manuten√ß√£o de uma popula√ß√£o de solu√ß√µes e a explora√ß√£o do espa√ßo de busca tanto de forma local no entorno das solu√ß√µes existentes quanto de forma global, ao abrir novos pontos de busca distantes das solu√ß√µes locais. Algumas das principais vantagens que os algoritmos gen√©ticos apresentam s√£o:</li>
  <ul>
<li>A possibilidade de realizar explora√ß√£o simult√¢nea em distintos pontos do espa√ßo de busca (que pode ser melhor explorada com o uso de computa√ß√£o paralela);</li>
  <li>O funcionamento em espa√ßos de busca cont√≠nuos ou discretos;</li>
  <li>O fato de n√£o serem sens√≠veis √† exist√™ncia de m√≠nimos locais;</li>
  <li>A capacidade de descobrir v√°rias solu√ß√µes (particularmente √∫til para fun√ß√µes multi-modais);</li>
<li>A caracter√≠stica de n√£o imporem condi√ß√µes especiais √† fun√ß√£o a ser otimizada (continuidade, exist√™ncia de derivada, etc.);</li>
  <li>A possibilidade de funcionarem bem em espa√ßos de busca com muitas dimens√µes;</li>
<li>A capacidade de permitirem modelar restri√ß√µes e otimizar simultaneamente m√∫ltiplas fun√ß√µes, mesmo que conflitantes;</li>
<li>A capacidade de ser facilmente mesclados com outras t√©cnicas heur√≠sticas, compondo solu√ß√µes h√≠bridas que exploram as qualidades individuais de cada t√©cnica espec√≠fica;</li>
<li>A caracter√≠stica de serem f√°ceis de implantar computacionalmente, n√£o dependendo de profunda compreens√£o do problema a ser otimizado e de sua modelagem.</li>
</ul>
<p>Entretanto, tais m√©todos s√£o computacionalmente intensos e podem demorar a convergir para uma solu√ß√£o aceit√°vel (dependendo da parametriza√ß√£o, como veremos adiante). Portanto, sua principal restri√ß√£o √© a utiliza√ß√£o em problemas de otimiza√ß√£o que exijam respostas em tempo real.</p>
</ol>



















