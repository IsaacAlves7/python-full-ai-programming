# <img src="https://i.pinimg.com/originals/87/8f/6e/878f6e65a76bde5169415e5b39226696.png" height="30"> Python AI Development ğŸğŸŒ³ğŸ§ ğŸ”€ğŸ§¬ğŸ¤–ğŸ‘¤ğŸ“ˆ
<p>It's a repository of full AI (Artificial Intelligence) programming using the Python language.</p>

<div align="left"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/python_button_icon_151925.png" height="47"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/r_button_icon_151924.png" height="47"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/ai_button_icon_151919.png" height="47"><img src="https://cdn.icon-icons.com/icons2/2530/PNG/512/iot_button_icon_151911.png" height="47"></div>
<a href="https://github.com/IsaacAlves7/python-programming"><img src="https://www.isktechnologies.com/img/blog/python-for-ai-mi-banner.jpg" width="1070" title="Click on image to access the Python programming repository"/></a>

<blockquote>âš ï¸ <b>Warning:</b> I recommend to repeat the same activities, do the exercices and execute the codes on your own machine. Besides that, it's a repository only focused in AI development, if you need to learn the Python Language and his paradigms, click on picture below to be redirected for the Python programming repository.</blockquote>

<h2>ğŸ Main menu - Overview about the Python AI ğŸğŸŒ³ğŸ§ ğŸ”€ğŸ§¬ğŸ¤–ğŸ‘¤ğŸ“ˆ:</h2>
<ol>
  <li><a href="https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-01--ai---artificial-intelligence-%EF%B8%8F">ğŸ§  AI - Artificial Intelligence ğŸ–¥ï¸</a></li>
  <li><a href="https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-02--descri%C3%A7%C3%A3o-das-estrat%C3%A9gias-de-busca-em-profundidade-">ğŸ” Graph search strategy at no cost ğŸŒ³</a></li>
  <li><a href="https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-03--regras-de-produ%C3%A7%C3%A3o-e-sistemas-especialistas-">ğŸ“– Production Rules and Expert Systems ğŸ’¼</a></li>
  <li><a href="https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-04--l%C3%B3gica-nebulosa-fuzzy-e-sistemas-baseados-em-regras-fuzzy-">ğŸ”€ Nebulous Logic (Fuzzy) and Systems based in Fuzzy rules ğŸ’¹</a></li>
  <li><a href="https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-05--fuzzy-system-building-%EF%B8%8F">ğŸ”€ Fuzzy system building ğŸ—ï¸</a></li>
  <li><a href="https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-06-%EF%B8%8F-evolved-systems-and-genetic-algorithms-">ğŸ‘¨â€âš•ï¸ Evolved Systems and Genetic Algorithms ğŸ§¬</a></li> 
  <li>ğŸ§  Redes Neurais ã€°ï¸</li>  
  <li>ğŸ Python Language and R-Project ğŸ“—</li>  
  <li>ğŸ§ª Data Science ğŸ“ˆ</li>  
  <li>ğŸ¤– Machine Learning ğŸ“š</li>  
  <li>ğŸ—£ï¸ Voice Recognition ğŸ‘‚</li>
  <li>ğŸ–¥ï¸ Computer Vision ğŸ‘ï¸</li>
  <li>ğŸš— Object Detection ğŸ‘ï¸â€ğŸ—¨ï¸</li>
  <li>ğŸ¦¾ Automation Systems ğŸ¦¿</li>
  <li>ğŸ‘¤ Deep Learning ğŸ“š</li>
  <li>ğŸ‘¥ Criando uma consciÃªncia ğŸ¤–</li>
  <li>ğŸ Final Project ğŸ¤©</li>
</ol>
<hr>
<h1 align="center" class="cap1">Cap 01: ğŸ§  AI - Artificial Intelligence ğŸ–¥ï¸</h1>
<img src="https://www.multimediadesignstudio.com.br/web/images/blog/inteligengia_artificial.jpg"/>
<p>Apesar de nÃ£o haver um consenso sobre o que seja exatamente <b>InteligÃªncia Artificial</b>, diferentes autores procuraram definir o termo ao longo do tempo. A seguir listamos algumas dessas definiÃ§Ãµes:</p>
<blockquote><i>"A automaÃ§Ã£o de atividades que associamos ao pensamento humano, atividades tais como tomadas de decisÃ£o , resoluÃ§Ã£o de problemas, aprendizado .." - <b>Bellman</b>, 1978.</blockquote></i>
<blockquote><i>"O estudo das computaÃ§Ãµes que tornam possÃ­vel perceber, racionar e agir.â€ - <b>Winston</b>, 1992.</b></blockquote></i>
<blockquote><i>"A arte de criar mÃ¡quinas que executem funÃ§Ãµes que exijam inteligÃªncia quando executadas por pessoas.â€ - <b>Kurzweil</b>, 1990.</b></blockquote></i>
<blockquote><i>"O estudo de como fazer computadores realizarem coisas nas quais, no momento, as pessoas sÃ£o melhores.â€ - <b>Rich and Knight</b>, 1991.</b></blockquote></i>
<blockquote><i>"O campo de estudos que procura emular comportamento inteligente em termos de processos computacionais.â€ - <b>Schalkoff</b>, 1990.</b></blockquote></i>
<blockquote><i>"O ramo da ciÃªncia da computaÃ§Ã£o que estÃ¡ interessado em automatizar comportamento inteligente.â€ - <b>Luger e Stubblefield</b>, 1993.</b></blockquote></i>
<blockquote><i>"O campo de estudos que busca desenvolver tÃ©cnicas computacionais para realizar tarefas que requerem inteligÃªncia quando realizadas por seres humanos. Envolve o desenvolvimento de tecnologia que permita lidar com categorias tais como raciocÃ­nio, aprendizado e percepÃ§Ã£o.â€ - <b>Takimoto</b>, 1987.</b></blockquote></i>
<h2>ğŸ¤“ O que Ã© inteligÃªncia? ğŸ¤”</h2>
<img src="https://inteng-storage.s3.amazonaws.com/img/iea/QlO7z1Mew7/sizes/aidepositphotos_resize_md.jpg" width="1700"/>
<p>De fato, muitas das definiÃ§Ãµes citam <i>inteligÃªncia</i> como algo que se deseja <b>simular</b>, <b>emular</b> ou <b>mimetizar</b>. Logo, uma discussÃ£o anterior que se faz necessÃ¡ria Ã©: â€œO que Ã© inteligÃªncia?â€.<br>
  
Algumas possibilidades sÃ£o:
<ul>
  <li>Jogar xadrez?</li>
  <li>Entender a linguagem humana?</li>
  <li>Resolver problemas combinatÃ³rios trabalhosos e complexos?</li>
  <li>Decidir diante a incerteza?</li>   
  <li>Reconhecer um objeto pela a imagem?</li> 
  <li>Gabaritar uma prova com o pouco de conhecimento sobre a matÃ©ria?</li> 
  <li>Reconhecer o som de um objeto e saber distingui-lo?</li>   
  <li>Prever um acontecimento?</li>
  <li>Falar? Ouvir? Observar? Conversar? Responder? Perguntar? Pensar? Agir? Obedecer? Orientar? Ler? Desenhar? Cantar? Aprender? Refletir? Repetir? Interagir? Executar?  Trabalhar? Informar? Solicitar? Acessar? Proteger? Ensinar? Reconhecer? Raciocinar? Recomendar? Ou ainda mais polÃªmico... Amar?</li>
</ul>

De uma forma geral, o termo â€œinteligÃªnciaâ€ Ã© revestido de um glamour natural e que remete a coisas, originais, inovadoras ou difÃ­ceis de realizar pelo ser humano mÃ©dio.

Ã‰ provavelmente mais fÃ¡cil que alguÃ©m que tenha uma habilidade mental de realizar cÃ¡lculos aritmÃ©ticos complexos seja considerado "inteligente", do que supor inteligente alguÃ©m que pode realizar tarefas cotidianas e comezinhas como falar, reconhecer o rosto de uma pessoa, rir de algo engraÃ§ado ou decidir quando deve atravessar uma rua com trÃ¡fego intenso.
</p>

<h2>ğŸ±â€ğŸ‰ Alguns paradigmas da InteligÃªncia Artificial ğŸ±â€ğŸ</h2>
<p>Ao abordar tais questÃµes, os diversos paradigmas, atualmente pesquisados, obtÃ©m mais ou menos sucesso, de acordo com suas <b>caracterÃ­sticas</b>, <b>virtudes</b> e <b>limitaÃ§Ãµes</b>. Uma abordagem ligeira desses paradigmas, que serÃ£o estudados melhor ao longo da disciplina, Ã© feita a seguir:</p>

<h3>ğŸŒ³ Sistemas baseados em conhecimento</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)](https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#-sistemas-de-produ%C3%A7%C3%A3o-)

</div>
<ul>
  <li><b>Buscas em tabelas, Ã¡rvores de decisÃ£o, busca heurÃ­stica, sistemas baseados em regras</b>.</li>
  <li>Lidam com <b>conhecimento explÃ­cito e representado simbolicamente</b>.</li>  
  <li><b>Examinam o seu raciocÃ­nio</b>.</li> 
  <li>Podem <b>justificar conclusÃµes</b>.</li> 
  <li>Atuam mesmo com <b>conhecimento incompleto ou impreciso</b>.</li> 
  <li><b>Principais aplicaÃ§Ãµes:</b> jogos, configuraÃ§Ãµes de produtos, emissÃ£o de propostas, telemarketing, distribuiÃ§Ã£o, concessÃ£o de crÃ©dito, gestÃ£o de carteira, orientaÃ§Ã£o a clientes, seleÃ§Ã£o, orÃ§amento, planejamento estratÃ©gico, alocaÃ§Ã£o de recursos, diagnÃ³stico, terapÃªutica, sistemas tutoriais e psico-testes.</li>   
</ul>

<h3>ğŸ§  Modelos Conexionistas (Redes Neurais)</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)]()

</div>
<ul>
  <li>Lidam com <b>conhecimento nÃ£o simbolicamente representado</b>.</li>
  <li>Levemente <b>inspirados no comportamento do cÃ©rebro e seus neurÃ´nios</b>.</li>  
  <li>Processam a informaÃ§Ã£o de <b>forma paralela e distribuÃ­da</b>.</li> 
  <li>Aprendem com treinamento.</li> 
  <li><b>Generalizam o conhecimento aprendido</b>.</li> 
  <li>Por nÃ£o lidarem com conhecimento simbÃ³lico, <b>nÃ£o justificam decisÃµes</b>.</li>   
  <li><b>Algumas aplicaÃ§Ãµes:</b> Reconhecimento de fala, classificaÃ§Ã£o de sinais de sensores, reconhecimento de imagens, previsÃ£o de Ã­ndices do mercado financeiro, previsÃ£o de sÃ©ries temporais, reconhecimento de voz, aplicaÃ§Ãµes gerais de classificaÃ§Ã£o, agrupamento e previsÃ£o.</li>    
</ul>

<h3>ğŸ”€ Sistemas Nebulosos (LÃ³gica Fuzzy)</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)](https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-04--l%C3%B3gica-nebulosa-fuzzy-e-sistemas-baseados-em-regras-fuzzy-)

</div>
<ul>
  <li>Modelam os <b>modos imprecisos do raciocÃ­nio aproximado que influenciam na habilidade humana de tomar decisÃµes</b>.</li>
  <li>Realizam o <b>raciocÃ­nio aproximado, com proposiÃ§Ãµes imprecisas, descritas em linguagem natural usando a teoria de conjuntos nebulosos como ferramenta para convertÃª-las em formato numÃ©rico.</b></li>  
  <li><b>Algumas aplicaÃ§Ãµes:</b> controle de aeronaves, operaÃ§Ã£o do metrÃ´, transmissÃ£o automÃ¡tica de veÃ­culos, controle de elevadores, anÃ¡lise do mercado de aÃ§Ãµes, ajuste da imagem de TV, autofocus para cÃ¢mera de vÃ­deo, estabilizador de imagens de filmadoras, controle de mÃ¡quinas de lavar e sistemas de ar condicionado.</li>    
</ul>

<h3>ğŸ§¬ ComputaÃ§Ã£o EvolucionÃ¡ria (Algoritmos GenÃ©ticos)</h3>
<div align="center">

[![Probot](https://img.shields.io/badge/-View-blue?style=for-the-badge&logo=Probot&logoColor=white)](https://github.com/IsaacAlves7/python-ai-development/blob/main/README.md#cap-06-%EF%B8%8F-evolved-systems-and-genetic-algorithms-)

</div>
<ul>
  <li>SÃ£o algoritmos de otimizaÃ§Ã£o global que baseiam-se nos mecanismos da <b>seleÃ§Ã£o natural e da genÃ©tica</b>.</li>
  <li>Empregam <b>uma estratÃ©gia de busca paralela e estruturada</b>, que Ã© voltada em direÃ§Ã£o ao reforÃ§o da busca de pontos de â€œalta aptidÃ£oâ€.</li>  
  <li>Exploram informaÃ§Ãµes histÃ³ricas para <b>encontrar novos pontos de busca</b>, onde sÃ£o esperados melhores desempenhos, atravÃ©s de processos iterativos, onde <b>cada iteraÃ§Ã£o Ã© chamada de "geraÃ§Ã£o"</b>.</li> 
  <li><b>Algumas aplicaÃ§Ãµes:</b> problemas gerais de roteamento, controle de sistemas dinÃ¢micos, induÃ§Ã£o e otimizaÃ§Ã£o de bases de regras, encontrar topologias conexionistas, simulaÃ§Ã£o de modelos biolÃ³gicos, evoluÃ§Ã£o interativa de imagens.</li>   
</ul>

<p>Em suma, o <b>conhecimento</b> Ã© a base para o desenvolvimento de modelos que envolvam <b>inteligÃªncia</b>.

A primeira tÃ©cnica que estudaremos, aplica-se a uma <em>classe de problemas</em> que serÃ¡ definida mais Ã  frente e que Ã© genericamente chamada de <b>Sistemas de ProduÃ§Ã£o</b>.</p>

<h2>ğŸ§° Sistemas de ProduÃ§Ã£o ğŸ¦¾</h2>
<img src="https://intellipaat.com/blog/wp-content/uploads/2020/05/Production-System-in-Artificial-Intelligence-Big.jpg" width="1000"/>
  
<blockquote><b>Sistemas de ProduÃ§Ã£o</b> sÃ£o sistemas computacionais de <em>propÃ³sito especÃ­fico</em>, baseados em <em>conhecimento restrito e especificÃ¡vel</em>.</blockquote> 

O tipo de problema que pode ser abordado com essa tÃ©cnica deve possuir trÃªs caracterÃ­sticas:
<ol>
<li>A primeira delas Ã© que deve ser possÃ­vel <em>representar e reconhecer as situaÃ§Ãµes estÃ¡ticas do problema</em>, que podem ser chamadas de â€œ<b>estados</b>â€. Ou seja, sÃ£o problemas caracterizados por <em>evoluÃ­rem em uma sequÃªncia de estados distintos e identificÃ¡veis</em>.</p>
<h3>1. Exemplo: ğŸ§°â™šâ™›â™œâ™â™â™Ÿ Xadrez â™™â™˜â™—â™•â™–â™”ğŸ¦¾</h3>
<p>Por exemplo, os problemas que envolvem <em>jogos de tabuleiro</em>, em geral possuem essa caracterÃ­stica. Em um jogo de <b>xadrez</b>, damas ou gamÃ£o, a situaÃ§Ã£o do tabuleiro apÃ³s cada lance de um dos adversÃ¡rios caracteriza <b>um â€œestadoâ€</b> do jogo. 
<br>&nbsp;
<img src="https://blog.megajogos.com.br/wp-content/uploads/2019/10/banner_xadrez.png" width="1050" title="Chess"/>

O jogo em si Ã© uma sucessÃ£o de <i>estados distintos, reconhecÃ­veis e identificÃ¡veis</i>.</li> 

<li>AlÃ©m de estados, esse tipo de problema tambÃ©m se caracteriza por ter â€œ<b>operaÃ§Ãµes</b>â€ conhecidas que <em>ocasionam as mudanÃ§as de estado</em>. Nos jogos de tabuleiro, por exemplo, as operaÃ§Ãµes sÃ£o as movimentaÃ§Ãµes possÃ­veis das peÃ§as, impostas pelas regras do jogo.</li>

<li>A terceira condiÃ§Ã£o que deve estar presente Ã© haver um "<b>estado inicial</b>" e um ou mais "<b>estados finais</b>" a serem atingidos. Nos jogos de tabuleiro a situaÃ§Ã£o inicial Ã© a posiÃ§Ã£o das peÃ§as antes do inÃ­cio do jogo e a situaÃ§Ã£o final Ã© um estado que caracterize o encerramento do jogo, quer com a vitÃ³ria de algum dos oponentes, quer com o empate.</li>
</ol>

Em um jogo de xadrez isso pode ser caracterizado tanto por um â€œcheque mateâ€ (vitÃ³ria) quanto por um â€œafogamento do rei (empate)â€. Naturalmente existem muitas configuraÃ§Ãµes de â€œcheque mateâ€, mas o importante Ã© que esse estado pode ser caracterizado e reconhecido. AlÃ©m de jogos de tabuleiro muitos outros problemas possuem essas caracterÃ­sticas. 

Uma <em>classe importante</em> deles, que constituem uma das principais aplicaÃ§Ãµes prÃ¡ticas para as tÃ©cnicas que estudaremos a seguir, sÃ£o os problemas de <em>roteamento</em> em geral.

<blockquote>Os <b>Sistemas de ProduÃ§Ã£o</b> se caracterizam como sendo possuidores de uma <b>base de estados, um conjunto de operadores e uma estratÃ©gia de controle</b>.</blockquote>

A <b>bases de estados</b> Ã© o conjunto de configuraÃ§Ãµes que o problema pode assumir.

Os <b>operadores</b> executam <em>transformaÃ§Ãµes na base de estados</em>, ou seja, <em>levam o problema de um estado a outro</em>. Resolver o problema Ã©, na verdade, determinar a <em>sequÃªncia de operadores</em> que deve ser aplicada a partir do <em>estado inicial</em>, de forma a atingir <em>um dos estados finais</em>. 

Se pudermos escolher entre diversos operadores em uma determinada situaÃ§Ã£o, entÃ£o precisamos de uma <b>estratÃ©gia de controle</b>.

<h4>O sistema basicamente computa:</h4>
<pre><b>Estado &larr; estado inicial</b></pre>

<h4>Enquanto nÃ£o for satisfeita uma condiÃ§Ã£o de tÃ©rmino: Selecione um operador R</h4>
<pre><b>Novo estado &larr; R (estado atual)</b></pre>

A condiÃ§Ã£o de tÃ©rmino Ã© alcanÃ§ada se foi atingido um estado final, se nÃ£o hÃ¡ mais operadores aplicÃ¡veis ao estado atual ou se nÃ£o hÃ¡ mais recursos computacionais.</p>

<h3>ğŸ§°ğŸ…°ï¸â¡ï¸ RepresentaÃ§Ã£o dos Sistemas de ProduÃ§Ã£o ğŸ…±ï¸â¡ï¸ğŸ¦¾</h3>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100785707-cc235500-33ef-11eb-88f5-0de1f2fbd3c8.jpg"/></div>
<p align="center"><em><strong>figura 1.1:</strong> Grafo</em></p>
<blockquote>Ã‰ possÃ­vel representar um <i>Sistema de ProduÃ§Ã£o</i> atravÃ©s de <b>Grafos de Estado</b>.</blockquote>
<p>Os <b>grafos</b> sÃ£o constituÃ­dos por <b>conjuntos de vÃ©rtices e de arestas</b>. Ã‰ possÃ­vel representar graficamente este conceito. 

Por exemplo, um <em>grafo</em> <b>G</b> com <em>vÃ©rtices</em> <b>V</b> = {a, b, c} e <em>arestas</em> <b>A</b> = ((a, b), (a, c)), pode ser representado graficamente como na figura.</p>

<p>Em um <strong>grafo de estados</strong>, cada vÃ©rtice representa um estado e cada aresta a aplicaÃ§Ã£o de um operador que causa a mudanÃ§a de estado.</p>
  
Vamos apresentar um exemplo que pode ser representado como um grafo de estados e Ã© conhecido como o problema dos <b>jarros dâ€™Ã¡gua</b>:

<h3>2. Exemplo: ğŸ§°ğŸº Jarros d'Ã¡gua ğŸºğŸ¦¾</h3>
<div align="center"><img src="https://media.istockphoto.com/vectors/ancient-pottery-vase-jar-amphora-made-in-cartoon-flat-style-vector-id809864684?k=6&m=809864684&s=170667a&w=0&h=LIzEbFmYisGVDMypFKZVhgcoRqDthflZqwLoBn9T1PA=" height="270" title="Jar A"/><img src="https://media.istockphoto.com/vectors/ancient-pottery-vase-jar-amphora-made-in-cartoon-flat-style-vector-id809864684?k=6&m=809864684&s=170667a&w=0&h=LIzEbFmYisGVDMypFKZVhgcoRqDthflZqwLoBn9T1PA=" height=270" title="Jar B"/></div>
<p>Considere <b>dois jarros opacos</b>, nos quais nÃ£o Ã© possÃ­vel observar o conteÃºdo. Um <strong>jarro A</strong> tem capacidade para 4 litros e um <strong>jarro B</strong> tem capacidade para 3 litros. Queremos colocar exatamente dois litros de Ã¡gua no <strong>jarro A</strong>. Para tanto, temos as seguintes operaÃ§Ãµes disponÃ­veis: <em>encher</em> totalmente um dos jarros; <em>esvaziar</em> totalmente um dos jarros; e, <em>passar</em> o conteÃºdo de um jarro para o outro.<br>

Primeiramente, Ã© preciso arrumar uma representaÃ§Ã£o para o problema, pois somente assim serÃ¡ possÃ­vel caracterizar e reconhecer os estados do problema. Cada problema pode ter uma representaÃ§Ã£o distinta. O estado de uma partida de xadrez, por exemplo, pode ser uma </em>foto do tabuleiro ou uma descriÃ§Ã£o textual das posiÃ§Ãµes das peÃ§as</em>. Devemos escolher a representaÃ§Ã£o mais simples possÃ­vel. Para este problema, o que caracteriza cada estado Ã© a <em>quantidade de Ã¡gua em cada jarro</em>. Portanto, pode-se criar uma representaÃ§Ã£o que seja um par de nÃºmeros, onde o primeiro nÃºmero representa a quantidade de litros de Ã¡gua no jarro A e o segundo a quantidade no jarro B. Assim, por exemplo, (2, 3) indica que hÃ¡ 2 litros no jarro A e 3 litros no jarro B.<br>

As operaÃ§Ãµes possÃ­veis de realizar com os jarros constituem as arestas do grafo e, para esse caso, podem ser assim listadas e nomeadas:
<ul>
  <li><b>R1</b> â€“ encher o jarro A</li>
  <li><b>R2</b> â€“ encher o jarro B</li>
  <li><b>R3</b> â€“ esvaziar o jarro A</li>
  <li><b>R4</b> â€“ esvaziar o jarro B</li>
  <li><b>R5</b> â€“ passar a Ã¡gua do jarro A para o jarro B</li>
  <li><b>R6</b> â€“ passar a Ã¡gua do jarro B para o jarro A</li>
</ul>
Inicialmente os jarros estÃ£o vazios, assim, o estado inicial Ã© (0, 0). O que objetivamos Ã© colocar 2 litros no jarro A, portanto, nos interessa alcanÃ§ar um estado (2, x), onde x Ã© um valor qualquer. Um grafo, com algumas das possÃ­veis transiÃ§Ãµes, teria a forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100782443-308fe580-33eb-11eb-9846-fd2a0ef91e62.jpg"/></div>
<p align="center"><em><strong>Figura 1.2:</strong> Um grafo com alguns estados e transiÃ§Ãµes do problema das jarras.</em></p>
<blockquote><strong>âš ï¸ AtenÃ§Ã£o!</strong> Em um <b>grafo de estados</b> pode haver ciclos de forma que operaÃ§Ãµes sucessivas causem retorno a um estado anterior. Essa situaÃ§Ã£o Ã© indesejada, como indicado na parte mais de baixo da figura 1.2, na qual a aplicaÃ§Ã£o sucessiva dos operadores R1 e R3 causou o retorno ao estado inicial. </blockquote>
<h2>ğŸ§°ğŸ” DefiniÃ§Ã£o de uma estratÃ©gia ou mÃ©todo de busca ğŸ”ğŸ¦¾</h2>
<p>O objetivo em um <em>Sistema de ProduÃ§Ã£o</em> Ã© obter uma sequÃªncia de operadores que levem um problema do estado inicial a um estado final. A forma sistemÃ¡tica de percorrer o grafo Ã  procura desta seqÃ¼Ãªncia, Ã© chamada de <b>MÃ©todo ou EstratÃ©gia de Busca</b>. Um MÃ©todo de Busca constrÃ³i uma <b>Ãrvore de Busca</b>, na qual a raiz Ã© o estado inicial e os nÃ³s filhos sÃ£o obtidos pela aplicaÃ§Ã£o sucessiva dos operadores.
<div align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5d/Breadth-First-Search-Algorithm.gif/250px-Breadth-First-Search-Algorithm.gif"/></div>
Cada estado sÃ³ deve aparecer uma vez na Ã¡rvore, de forma que, caso a aplicaÃ§Ã£o de um operador sobre um determinado estado leve a outro estado que jÃ¡ estÃ¡ na Ã¡rvore, entÃ£o este novo estado deve ser descartado (nÃ£o deve ser incluÃ­do na Ã¡rvore). Isto equivale a dizer que este operador nÃ£o Ã© aplicÃ¡vel a este estado neste ramo especifico da Ã¡rvore.</p>

# ğŸ”ğŸ“— SÃ­ntese do CapÃ­tulo 1 ğŸ“—ğŸ”
<blockquote></blockquote>
<hr>
<h1>Cap 02: ğŸ” DescriÃ§Ã£o das estratÃ©gias de busca em profundidade ğŸŒ³</h1>
<p>A estratÃ©gia mais simples possÃ­vel Ã© a <b>busca em profundidade</b>. Este mÃ©todo procura uma soluÃ§Ã£o qualquer (que nÃ£o Ã© garantidamente a melhor) e encontra-a ou nÃ£o (o mÃ©todo nÃ£o garante que uma soluÃ§Ã£o serÃ¡ encontrada). 

A estratÃ©gia consiste em expandir os estados a partir do estado inicial, aplicando qualquer um dos possÃ­veis operadores aplicÃ¡veis Ã quele estado. A escolha do operador pode ser aleatÃ³ria ou seguir uma sequÃªncia arbitrÃ¡ria de testes de possibilidade de aplicaÃ§Ã£o dos operadores. Caso nÃ£o haja operadores possÃ­veis de aplicar ou caso todos os estados gerados jÃ¡ constem da Ã¡rvore, o mÃ©todo fracassa. O mÃ©todo obtÃ©m sucesso apenas se atinge um estado final.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100808560-22ee5600-3413-11eb-8ded-c4870cb10fc2.jpg"/></div>
<p align="center"><em><strong>Figura 1.3:</strong> Uma busca em profundidade com backtracking.</em></p>
<p>Existe ainda uma alteraÃ§Ã£o que melhora a busca em profundidade. Neste mÃ©todo, quando o algoritmo fracassa em atingir m estado final, de acordo com os critÃ©rios do mÃ©todo irrevogÃ¡vel, volta-se para o nÃ³ pai e escolhe-se outro operador. Caso nÃ£o seja possÃ­vel escolher outro operador para este nÃ³, volta-se mais um nÃ­vel, repetindo-se o processo atÃ© que seja atingido o nÃ³ raiz. 

Por causa da volta ao nÃ³ pai, este mÃ©todo tambÃ©m Ã© conhecido como <b>backtracking</b>. Agindo desta forma, o algoritmo garante que, caso haja alguma soluÃ§Ã£o, ela serÃ¡ encontrada, jÃ¡ que todos os caminhos serÃ£o investigados (a busca Ã© exaustiva). Veja uma ilustraÃ§Ã£o da estratÃ©gia no grÃ¡fico da figura 1.3.
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100810014-3fd85880-3416-11eb-9707-9889dc5aa113.jpg"/></div>
<p align="center"><em><strong>Figura 1.4:</strong> Uma busca em largura.</em></p>

<p>Neste mÃ©todo, ao invÃ©s de escolhermos um operador para ser aplicado em um estado, geramos um novo estado e repetirmos o processo sucessivamente. Assim, o que se faz Ã© investigar todos os operadores que podem ser aplicados Ã quele nÃ³ e gerar todos os filhos possÃ­veis. Veja o grÃ¡fico explicativo da estratÃ©gia na figura 1.4.

Este mÃ©todo sempre encontra o caminho, caso ele exista. Como expande um nÃ­vel de cada vez, o mÃ©todo tambÃ©m encontra o caminho mais curto (em nÃºmero de transiÃ§Ãµes) entre a raiz e o estado final. Entretanto, a quantidade de possibilidades avaliadas Ã© muito grande, o que torna o mÃ©todo computacionalmente intenso.</p>
<h2>ğŸ’µğŸ…°ï¸ Grafos com custo ğŸ…±ï¸ğŸ’µ</h2>
<p>Em alguns tipos de problemas, o caminho de um estado para o prÃ³ximo possui um custo associado. Na pratica, todos os problemas importantes de roteamento possuem custos envolvidos. Ã‰ o caso de rotas de transporte de cargas, rotas de distribuiÃ§Ã£o de energia elÃ©trica, rotas de encaminhamento de ligaÃ§Ãµes telefÃ´nicas, etc. 
</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100899190-52976f80-34a0-11eb-844e-f5026bb7be57.jpg"/></div>
<p align="center"><em><strong>figura 1.5:</strong> Uma configuraÃ§Ã£o de grafo com custos</em></p>
<p>Os problemas de encontrar uma rota de um ponto a outro sÃ£o uma simplificaÃ§Ã£o do problema mais genÃ©rico conhecido como o <b>â€œproblema do caixeiro viajanteâ€</b>. No problema do caixeiro viajante original, temos um conjunto de cidades ligadas por estradas, que possuem um <b>custo</b> de ligaÃ§Ã£o entre elas e se deseja percorrer todas as cidades ao menor custo possÃ­vel sem repetir nenhuma cidade. A figura exibe uma configuraÃ§Ã£o possÃ­vel para essa interligaÃ§Ã£o entre cidades, nas quais as cidades sÃ£o os <b>vÃ©rtices do grafo</b> e as ligaÃ§Ãµes entre elas sÃ£o as <b>arestas do grafo</b>.</p>

<p>Na versÃ£o mais simplificada, Ãºtil para um problema de roteamento, o objetivo Ã© levar o caixeiro de um ponto determinado a outro, ao menor custo possÃ­vel. Se quisermos ir da <em>cidade A</em> atÃ© a <em>cidade E</em>, temos custos diferentes para cada caminho. Alguns desses custos sÃ£o:</p>
<ul>
  <li><strong>ABCE</strong> â€“ custo: 3+5+8 = 16 </li>
  <li><strong>ACE</strong> â€“ custo: 4+8 = 12</li>
  <li><strong>ACDE</strong> â€“ custo: 4+7+4 = 15</li>  
  <li><strong>ADE</strong> â€“ custo: 6+4 = 10</li>  
</ul>

<h2>ğŸ”ğŸ˜‹ Busca gulosa ou busca pelo vizinho mais prÃ³ximo ğŸ˜ğŸ”</h2>
<p>Uma estratÃ©gia possÃ­vel, embora bastante simplÃ³ria, Ã© a <b>busca pelo vizinho mais prÃ³ximo</b> ou <b>busca gulosa</b>. Neste caso, escolhemos a cada passo o vizinho ainda nÃ£o visitado que apresente o menor custo (nÃ£o devemos repetir cidades, sob o risco de introduzir ciclos, como nas buscas nÃ£o ponderadas por custos).

Esta estratÃ©gia equivale, em algum sentido, Ã  busca irrevogÃ¡vel, na medida que nÃ£o garante encontrar um caminho, muito menos o de menor custo. No exemplo anterior, seguindo esta estratÃ©gia, a rota escolhida seria ABCDE, o que representaria um custo de 3+5+7+4=19. Como pode ser visto, comparando com o custo apurado para os outros caminhos, este caminho Ã© pior que todos os acima sugeridos. Logo, esta nÃ£o Ã© uma boa estratÃ©gia.</p>

<h2>ğŸ” Busca ordenada ou busca pelo caminho de soma mÃ­nima (algoritmo de Dijikstra) ğŸ§®</h2>
<p>Uma outra estratÃ©gia Ã© guardar a soma do custo de cada caminho e procurar a cada passo o caminho que implicarÃ¡ na menor soma. Esta estratÃ©gia Ã© parecida com a <b>busca em largura</b> ou <b>algoritmo de Dijikstra</b>. A diferenÃ§a Ã© que, caso um nÃ³ deva ser colocado na Ã¡rvore, mas jÃ¡ apareÃ§a em algum outro caminho (outro ramo diferente deste), deve haver uma comparaÃ§Ã£o entre os custos totais destes dois nÃ³s e eliminado o de maior custo. Analisemos passo a passo a aplicaÃ§Ã£o do algoritmo para o grafo anteriormente apresentado (Aâ†’E):</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100933996-e3844000-34cc-11eb-8c3a-80653e4aaa9e.jpg"/></div>
<p align="center"><em><strong>Figura 1.6:</strong> Passo 1.</em></p>
<p>ApÃ³s este passo, o custo total de cada caminho Ã©: AB=3, AC=4 e AD=6. Escolhendo o de menor custo total (AB), expandimos um nÃ­vel.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100936388-31e70e00-34d0-11eb-9c8d-5663e7fc567b.jpg"/></div>
<p align="center"><em><strong>Figura 1.7:</strong> Passo 2.</em></p>
<p>Como o novo nÃ³ jÃ¡ aparece na lista, devemos comparar o custo total desta apariÃ§Ã£o na lista (ABC:3+5=8) com a anterior (AC:=4). Como a anterior possui custo menor, abandonamos esta inserÃ§Ã£o e, como nÃ£o hÃ¡ mais caminhos a analisar para este nÃ³ (dizemos que ele estÃ¡ fechado), voltamos ao anterior (A) e escolhemos o segundo menor custo dentre os caminhos disponÃ­veis (AC=4).</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100939644-66a99400-34d5-11eb-987e-8015155d0e0c.jpg"/></div>
<p align="center"><em><strong>Figura 1.8:</strong> Passo 3.</em></p>
<p>Note que nÃ£o foi colocado o nÃ³ A porque o caminho ACA nÃ£o deve ser considerado, pois o nÃ³ A jÃ¡ estÃ¡ neste ramo da Ã¡rvore. O nÃ³ B, que jÃ¡ aparece em outro ramo, deve ser agora verificado com respeito ao custo total, o que acarreta em comparar o custo do caminho ACB (5+4=9) com o custo do caminho AB (3).

Assim, o caminho ACB deve ser desprezado. TambÃ©m o nÃ³ D jÃ¡ aparece em outro ramo, de forma que comparando o custo do caminho AD (=6) com o custo do caminho ACD (4+7=11), desprezamos este Ãºltimo. Note tambÃ©m que o nÃ³ de destino (E) jÃ¡ estÃ¡ na Ã¡rvore, mas devemos continuar o processamento atÃ© que todos os nÃ³s estejam fechados.</p>

<div align="center"><img src="https://user-images.githubusercontent.com/61624336/100943163-79bf6280-34db-11eb-9c0d-45b64241438c.jpg"/></div>
<p align="center"><em><strong>Figura 1.9:</strong> Passo 4.</em></p>
<p>Tanto o nÃ³ E como o nÃ³ C jÃ¡ aparece na lista. Para o nÃ³ C, temos que o caminho ADC tem custo 13 e o caminho AC tem custo 4. Logo, desprezamos C como filho de D.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/101107170-7d70e900-35b0-11eb-81cf-e0a45d0114f1.jpg"/></div>
<p align="center"><em><strong>Figura 1.10:</strong> Passo 5.</em></p>
<p>JÃ¡ o caminho ACE tem custo 12, enquanto que o caminho ADE tem custo 10. Desprezamos ACE. Logo:

Agora resta como aberto apenas o nÃ³ E. Como ele Ã© terminal, podemos parar o processo, pois qualquer caminho dele derivado serÃ¡ maior que o caminho atÃ© ele, haja vista que o custo sempre Ã© positivo. O caminho encontrado (ADE) Ã© o caminho Ã³timo (de menor custo). Para encontrar este caminho, o algoritmo fechou 2 nÃ³s fora do caminho Ã³timo (B e C) e 3 no caminho Ã³timo (A, D e E).</p>

<h1>Cap 03: ğŸ“– Regras de ProduÃ§Ã£o e Sistemas Especialistas ğŸ’¼</h1>
<h2>ğŸ§  Outras formas de representar conhecimento ğŸ’¡</h2>
<div align="center"><img src="https://s3.amazonaws.com/ibc-portal/wp-content/uploads/2016/05/22115051/o-que-e-conhecimento.jpg" width="1700"/></div>
<p>Para representar o conhecimento, pelo que acabamos de ver, devemos possuir formas de representar tanto as <em>informaÃ§Ãµes</em>, como os <em>procedimentos</em> (aÃ§Ãµes). Existem vÃ¡rias formas de representaÃ§Ã£o do conhecimento, tais como <b>Redes SemÃ¢nticas</b>, <b>Objetos Estruturados</b>, <b>LÃ³gica de Primeira Ordem</b> ou <b>Regras de ProduÃ§Ã£o</b>. A forma que estudaremos nesta aula sÃ£o os <b>sistemas de Regras de ProduÃ§Ã£o</b> (com os quais se constroem aplicaÃ§Ãµes chamadas de Sistemas Especialistas).

Para que possamos compreendÃª-los, Ã© necessÃ¡rio entender com quais <em>entidades</em> precisamos lidar. Fundamentalmente, podemos falar em duas entidades: os <b>fatos</b> (As verdades ou informaÃ§Ãµes que possuÃ­mos sobre um determinado contexto) e a <b>representaÃ§Ã£o dos conhecimentos</b> (Formalismo simbÃ³lico que permite representar e manipular o conhecimento emÂ  um determinado contexto).

A forma de representaÃ§Ã£o mais comum Ã© a <b>linguagem natural</b>. Mas podemos empregar tambÃ©m a lÃ³gica matemÃ¡tica como formalismo representacional. Considere o exemplo abaixo:</p>

### Exemplo: ğŸ§ ğŸº Cachorro Thor ğŸ¦´ğŸ’¡
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>1 - Thor Ã© um cachorro</strong></p>
<p>Este fato pode ser representado em um formalismo lÃ³gico como:
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>2 - cachorro Thor</strong></p>
<p>Se tivermos um formalismo para representar que todos os cachorros tem rabo, poderÃ­amos escrever:</p>
<p align="center"><strong>3-</strong><code>âˆ€x:cachorro(x)â‡¾tem-rabo(x)</code></p>
<p>&nbsp;</p>
<p>Usando mecanismos de deduÃ§Ã£o lÃ³gica, poderÃ­amos concluir:</p>
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>4 - Tem-rabo (Thor)</strong></p>
<p>Que em linguagem natural equivale a:</p>
<div align="center"><img src="https://www.racoesreis.com.br/wordpress/wp-content/uploads/imagem_do_post-49.jpg" width="1700"/></div>
<p align="center"><strong>5 - Thor tem rabo</strong></p>
<p>Este novo fato, pode ser considerado agora, justamente com os demais conhecimentos existentes para produzir novas inferÃªncias, ou seja, gerar novos fatos.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/101213527-47d40a80-3659-11eb-8faa-86a53413755a.jpg"/></div>
<p>Se esta geraÃ§Ã£o tiver uma orientaÃ§Ã£o adequada, poderemos produzir fatos que sejam relevantes em um determinado contexto, ou seja, poderemos encontrar as respostas que objetivamos.</p>

<h2>ğŸ“– Regras de ProduÃ§Ã£o ğŸ’¼</h2>
<div align="center"><img src="https://endoscopiaterapeutica.com.br/wp-content/uploads/2018/10/333333333333-2006x760.png" width="1700"/></div>

<p>Outra forma de representar o conhecimento Ã© atravÃ©s de <b>regras</b>.

<b>Sistemas baseados em regras</b> foram bastantes populares no inÃ­cio das pesquisas com IA e ainda tem larga utilizaÃ§Ã£o para modelar regras de negÃ³cio de aplicaÃ§Ãµes especializadas em uma determinada Ã¡rea. Tais conhecimentos sÃ£o conhecidos como <b>Sistemas Especialistas</b>. As regras sÃ£o uma forma de representaÃ§Ã£o do conhecimento bastante prÃ³xima da forma humana de expressÃ¡-lo.

Por exemplo, conhecimento como os abaixo expressos, podem ser fÃ¡cil e naturalmente postos em formas de regras:
<ul>
  <li>Se a temperatura Ã© maior que 38 graus, o paciente tem febre.</li>
  <li>Se o paciente tem febre hÃ¡ mais de 3 dias, o paciente tem uma infecÃ§Ã£o.</li> 
  <li>Se hÃ¡ tensÃ£o na entrada da fonte e nÃ£o hÃ¡ tensÃ£o na saÃ­da da fonte, entÃ£o o transformador estÃ¡ queimado.</li>   
</ul>
Uma regra Ã© formada por uma <em>premissa simples ou composta</em> (usando operadores lÃ³gicos) e uma ou mais conclusÃµes que sÃ£o acionadas quando as premissas sÃ£o verdadeiras. As premissas/conclusÃµes sÃ£o tambÃ©m chamadas de situaÃ§Ã£o/aÃ§Ã£o ou ainda de antecedente/consequente das regras. Os <b>sistemas baseados em regras</b> usam inferÃªncia <b>Modus Pones</b>. Assim, dado que o fato A Ã© verdadeiro e a implicaÃ§Ã£o AÂ®B Ã© verdadeira, conclui-se que o fato B Ã© verdadeiro. Os sistemas que usam esta tÃ©cnica de representaÃ§Ã£o empregam tÃ©cnicas de busca por regras e inferÃªncia de novos fatos, de forma a encontrar os fatos que tenham sido definidos como objetivos. A ideia Ã© encontrar um caminho entre os fatos e conhecimentos que se tem e os fatos que se deseja descobrir.</p>
<p>Por exemplo, considere que temos os seguintes conhecimentos:</p>
<ul>
  <li><b>Regra 1:</b> Se a temperatura ambiente estÃ¡ acima de 35 graus. EntÃ£o o tempo estÃ¡ quente.</li>
  <li><b>Regra 2:</b> Se a umidade relativa do ar Ã© maior que 75%. EntÃ£o a atmosfera estÃ¡ Ãºmida.</li>
  <li><b>Regra 3:</b> Se o tempo estÃ¡ quente e a atmosfera estÃ¡ Ãºmida.</li>
</ul>
<p>EntÃ£o Ã© provÃ¡vel que se formem tempestades. Considere ainda que conhecemos os seguintes fatos:</p>
<ul>
  <li><b>Fato 1:</b> A temperatura ambiente Ã© de 37 graus.</li>
  <li><b>Fato 2:</b> A umidade relativa do ar Ã© de 81%.</li>
</ul>
<p>As regras 1 e 2 podem, a partir deste fatos, concluir novos fatos:
<ul>
  <li><b>Fato 3:</b> O tempo estÃ¡ quente (da regra 1).</li>
  <li><b>Fato 4:</b> A atmosfera estÃ¡ Ãºmida (da regra 2).</li>
</ul>
<p>Os fatos 3 e 4 satisfazem as premissas da regra 3, levando a outro fato:</p>
<ul>
  <li><b>Fato 5:</b> Ã‰ provÃ¡vel que se formem tempestades.</li>
</ul>

## â™Ÿï¸ EstratÃ©gias de inferÃªncia ğŸ“¤
<p>A forma como percorremos as regras, produzindo as inferÃªncias, isto Ã©, a escolha de quais regras examinar e ativar, pode obedecer a duas abordagens bÃ¡sicas:</p>

### â™Ÿï¸ EstratÃ©gia dirigida a dados ğŸ²
<p>Na estratÃ©gia dirigida a dados (<b>forward chain</b>), acionam-se todas as regras que possam ser acionadas a partir dos dados (fatos) conhecidos.</p>

### â™Ÿï¸ EstratÃ©gia dirigida a objetivos ğŸ“‰
<p>Na estratÃ©gia dirigida a objetivos (<b>backward chain</b>), aciona-se somente as regras que possuam na conclusÃ£o algum dos objetivos que procuramos. Caso a premissa da regra que desejamos acionar seja desconhecida, estabelecemos esta premissa como o novo objetivo e passamos a buscar regras que a contenha na parte da conclusÃ£o. Assim, o objetivo original Ã© provisoriamente abandonado e serÃ¡ retomado (atravÃ©s do acionamento da regra abandonada) quando a premissa necessÃ¡ria Ã  obtenÃ§Ã£o do objetivo original tenha sido encontrada. O procedimento Ã© recorrente, isto Ã©, os objetivos sÃ£o provisoriamente abandonados tantas vezes quanta se faÃ§a necessÃ¡rio, formando uma cadeia de busca para trÃ¡s (backward chain).</p>

<p>Considere, por exemplo, que temos a seguinte base de conhecimentos:</p>
<ul>
  <li><b>Regra 1:</b> Se a taxa de juros Ã© baixa. EntÃ£o a bolsa de valores estÃ¡ em alta.</li>
  <li><b>Regra 2:</b> Se a taxa de juros Ã© alta. EntÃ£o a bolsa de valores estÃ¡ em baixa.</li>
  <li><b>Regra 3:</b> Se a cotaÃ§Ã£o do DÃ³lar estÃ¡ baixa. EntÃ£o a taxa de juros Ã© alta.</li>
  <li><b>Regra 4:</b> Se a cotaÃ§Ã£o do DÃ³lar estÃ¡ alta. EntÃ£o a taxa de juros Ã© baixa.</li>  
</ul>
<p>Considere tambÃ©m que conhecemos o seguinte fato:
  Fato 1: a cotaÃ§Ã£o do DÃ³lar estÃ¡ baixa.
  O que desejamos saber Ã©: "Qual a tendÃªncia da bolsa de valores?"</p>

![Sem TÃ­tulo-1](https://user-images.githubusercontent.com/61624336/101846230-4d38c580-3b2f-11eb-8dab-cd610df6415a.jpg)
<div align="center"><em><strong>Figura 1:</strong> EstratÃ©gia de busca orientada a dados</em></div></br>

<p>Onde as regras com cÃ­rculos serÃ£o acionadas, porque as premissas assim o permitem, enquanto que as demais serÃ£o apenas investigadas. Se a busca for com a abordagem orientada a objetivos, teremos a cadeia de investigaÃ§Ã£o e acionamento de regras da figura 2.</p>

![Qualquer coisa](https://user-images.githubusercontent.com/61624336/101947441-45306280-3bcf-11eb-9af5-fa5d985e2b92.jpg)
<div align="center"><em><strong>Figura 2:</strong> EstratÃ©gia de busca orientada a objetivos</em></div></br>
<p>Do primeiro para o segundo passo, o objetivo seria trocado de "bolsa de valores" para "taxa de juros" e iniciar-se-ia a busca por este novo objetivo. Quando ele fosse encontrado (apÃ³s o acionamento da regra 3), retornar-se-ia Ã  regra abandonada (regra 1) para buscar novamente pelo objetivo original, que seria encontrado apÃ³s o acionamento da regra 2.
 
O que acontece quando nÃ£o Ã© mais possÃ­vel encontrar regras que gerem o conhecimento objetivado, no esquema de backward chain ou nÃ£o Ã© mais possÃ­vel gerar novos conhecimentos no esquema forward chain? Bem, neste caso ocorre o mesmo que quando se vai a uma consulta mÃ©dica e somente com as informaÃ§Ãµes relatadas e o seu conhecimento, o mÃ©dico nÃ£o Ã© capaz ainda de produzir um diagnÃ³stico. Ele precisa agregar novos conhecimentos vindo de fora do sistema. Em uma consulta isto pode representar outras perguntas ao paciente ou a requisiÃ§Ã£o de exames complementares. Em um sistema especialista montado a partir de regras de produÃ§Ã£o, a agregaÃ§Ã£o de novos conhecimentos que nÃ£o sejam possÃ­veis de deduzir a partir das regras existentes, geralmente se dÃ¡ atravÃ©s de perguntas que se faz ao usuÃ¡rio sobre valores das variÃ¡veis que sejam importantes na cadeia de conhecimento necessÃ¡ria Ã  resoluÃ§Ã£o do problema que se objetiva.</p>

## â™Ÿï¸ EstratÃ©gias de inferÃªncia ğŸ“¤
<p>A evoluÃ§Ã£o na elaboraÃ§Ã£o de sistemas especialistas com estÃ³rias de sucesso levou os projetistas a separar os sistemas em trÃªs partes, de forma a facilitar a elaboraÃ§Ã£o de novos sistemas:</p>

![Sem TÃ­tulo-1](https://user-images.githubusercontent.com/61624336/101953638-71e97780-3bd9-11eb-9eca-1bea5f45494f.jpg)

<p>Esta estratÃ©gia acabou gerando o aparecimento de ambientes de desenvolvimento de sistemas especialista em que hÃ¡ algum tipo de editor e sintaxe para se editar a base de conhecimentos e estabelecer os fatos, acoplado a um motor de inferÃªncias para realizar as buscas.

Tais ambientes, denominados de Shells de Sistemas Especialistas, permitem que o usuÃ¡rio desenvolva sua prÃ³pria base de conhecimentos, de uma forma mais fÃ¡cil e rÃ¡pida. Alguns destes sistemas possuem ainda tradutores de cÃ³digo para alguma linguagem procedimental (C, por exemplo), permitindo que o sistema, apÃ³s ter sido depurado, seja integrado com o restante do cÃ³digo que tenha sido desenvolvido de forma tradicional./p>

## ğŸ¤” Lidando com incertezas ğŸ¤¨
<ol>
  <li>Muitas das decisÃµes que tomamos, sÃ£o baseadas em algum cÃ¡lculo da probabilidade de acerto, dadas as incertezas sobre os fatos conhecidos. Assim, um mÃ©dico Ã© capaz de diagnosticar mesmo sem ter certeza sobre os sintomas relatados pelo paciente, ou das taxas reportadas pelos exames. Da mesma forma, um analista financeiro Ã© capaz de tomar decisÃµes com boas perspectivasde acerto, mesmo diante das incertezas e conflitos dos indicadores do mercado financeiro. Esta capacidade inata do ser humano, estÃ¡ associada a algum tipo de cÃ¡lculo de probabilidades.</li>
  <li>Entretanto, implementar cÃ¡lculos estatÃ­sticos a partir dos princÃ­pios Bayesianos de probabilidade, torna os sistemas especialistas difÃ­ceis de especificar, na medida em que tratamentos rigorosamente matemÃ¡ticos de probabilidade utilizam informaÃ§Ãµes nem sempre disponÃ­veis ou simplificaÃ§Ãµes que nÃ£o sÃ£o claramente justificÃ¡veis em aplicaÃ§Ãµes prÃ¡ticas. Assim, foram construÃ­das alternativas que tambÃ©m lidam com confiabilidade das afirmativas, embora em uma base menos rigorosa e ligada basicamente Ã  teoria dos conjuntos.</li>
  <li>Na maioria dos sistemas, para cada afirmativa Ã© possÃ­vel usar um fator de confianÃ§a. Este fator Ã© um nÃºmero entre 0% e 100% que estÃ¡ relacionado Ã  expectativa de que aquela afirmativa seja verdadeira. A partir destes valores, se estabelece um limite (em geral 50%, mas que frequentemente pode ser mudado nas shells), para que as afirmativas sejam consideradas verdadeiras ou falsas. Assim, se temos uma variÃ¡vel Tempo que possui o valor Bom com um grau de confianÃ§a 55%, a regra: Se Tempo = Bom entÃ£o...., serÃ¡ ativada assim que seja examinada, dado que o fator de confianÃ§a do valor Bom Ã© maior que 50%. Caso o fator de confianÃ§a fosse 43%, a regra nÃ£o seria ativada, pois o valor Ã© menor que 50% e a premissa seria considerada Falsa.</li>
</ol>
<p>Os cÃ¡lculos com os fatores de confianÃ§a envolvem os operadores de implicaÃ§Ã£o (ENTÃƒO), conjunÃ§Ã£o (E) e disjunÃ§Ã£o (OU), da seguinte forma:</p>
<table>
  <tr>
    <td>Para operaÃ§Ãµes de implicaÃ§Ã£o</td>
    <td>Para operaÃ§Ãµes de conjunÃ§Ã£o</td>
    <td>Para operaÃ§Ãµes de disjunÃ§Ã£o</td>
  </tr>
    <tr>
    <td>O grau de confianÃ§a da premissa Ã© multiplicado pelo grau de confianÃ§a da conclusÃ£o;</td>
    <td>O grau de confianÃ§a de todas as premissas Ã© multiplicado para obter o grau de confianÃ§a da premissa composta;</td>
    <td>O grau de confianÃ§a de todas as premissas Ã© somado e o resultado Ã© subtraÃ­do da multiplicaÃ§Ã£o dos mesmos graus de confianÃ§a, para obter o grau de confianÃ§a da premissa composta.</td>
  </tr>
</table>
<p>Por exemplo, suponha que conhecemos os fatos A, C e E com confiabilidade de 90% e temos as seguintes regras:</p>
<ul>
  <li>Se A EntÃ£o B (confiabilidade 70%)</li>
  <li>Se B e C entÃ£o D (confiabilidade 100%)</li>
  <li>Se D ou E entÃ£o F (confiabilidade 40%)</li>
  <li>Se F entÃ£o G (confiabilidade 100%)</li>
</ul>
<ol>
  <li>A primeira regra leva a: CF(A) * CF(conclusÃ£o) = 0,9 * 0,7 = 0,63 = CF(B)</li>
  <li>A Segunda regra leva a: CF(B) * CF(C) = 0,63 * 0,9 = 0,567 * 1 = CF(D)</li>
<li>A terceira regra leva a: CF(D) + CF(E) - CF(D) * CF(E) = 0,567 + 0,9 - 0,567 * 0,9 =Â  1,467 - 0,51 = 0,957 * 0.4 = 0,383 = CF(F)</li>
  <li>A quarta regra nÃ£o serÃ¡ acionada porque CF(F) = 0,383 < 0,50</li>
</ol>
<p>Quando diferentes regras levam a diferentes graus de confianÃ§a para uma mesma variÃ¡vel, em geral Ã© tambÃ©m aplicado o cÃ¡lculo da disjunÃ§Ã£o para estes dois valores, como no caso do operador OU. Assim, para o exemplo acima, caso tivÃ©ssemos uma regra que fosse:

Se B entÃ£o F (confiabilidade 90%)
TerÃ­amos: CF(B) * 0,90 = 0,63 * 0,90 = 0,567 = CF(F)
Como a CF(F) anterior era 0,383, a nova CF(F) = 0,567 + 0,383 - 0,567 * 0,383 = 0,95 - 0,217 = 0,733 = CF(F)</p>
<p>Alguns sistemas tratam as operaÃ§Ãµes com fatores de confianÃ§a de uma forma alternativa, utilizando funÃ§Ãµes de mÃ¡ximo e mÃ­nimo. Assim as operaÃ§Ãµes de conjunÃ§Ã£o tÃªm seu fator de confianÃ§a resultante calculado como o mÃ­nimo entre os valores de confianÃ§a das diversas premissas. JÃ¡ a operaÃ§Ã£o de disjunÃ§Ã£o leva a um fator de confianÃ§a igual ao mÃ¡ximo dos fatores das premissas envolvidas. A operaÃ§Ã£o de implicaÃ§Ã£o, nesta forma de cÃ¡lculo, geralmente tambÃ©m Ã© feita atravÃ©s do produto entre o fator de confianÃ§a resultante da premissa e o fator de confianÃ§a atribuÃ­do Ã  implicaÃ§Ã£o. Se fosse realizado este tipo de cÃ¡lculo no exemplo acima, a regra 2 levaria a um grau de confianÃ§a para D de: CF(D) = Min (0,63 , 0,9) * 1 = 0,63 = CF(D). JÃ¡ a regra 3 levaria a: CF(F) = Max (0,63 , 0,9) * 0,4 = 0,9 * 0,4 = 0,36 = CF(F). 

Em qualquer caso, a atribuiÃ§Ã£o dos fatores de confianÃ§a relativos Ã s implicaÃ§Ãµes Ã© de responsabilidade do especialista que definiu a regra e, provavelmente, Ã© oriundo da experiÃªncia na aplicaÃ§Ã£o do conhecimento formal aprendido em casos de uso do passado.</p>

# Cap 04: ğŸ”€ LÃ³gica Nebulosa (Fuzzy) e Sistemas baseados em regras Fuzzy ğŸ’¹
<p>A <b>LÃ³gica Fuzzy</b> Ã© baseada na teoria dos conjuntos fuzzy. Tradicionalmente, uma proposiÃ§Ã£o lÃ³gica tem dois extremos: ou Ã© completamente verdadeiro ou Ã© completamente falso. </p>
<img src="https://emgotas.files.wordpress.com/2016/11/lc3b3gica-fuzzy2.jpg?w=840" width="1070"/>

## ğŸ”€ Conjuntos Nebulosos (Conjuntos Fuzzy) ğŸŒ
<p>Um <b>conjunto nebuloso</b>, tambÃ©m chamado de <b>conjunto fuzzy</b>, Ã© uma funÃ§Ã£o que permite a entrada de um valor escalar e fornece como saÃ­da um nÃºmero entre zero e um, que representa o grau de pertinÃªncia (Âµ) da entrada ao conjunto fuzzy. Por exemplo, podemos definir o conjunto de pessoas altas com dois diferentes tipos de funÃ§Ã£o ilustrados na figura.</p>
<div align="center"><em><strong>Conjunto crisp e conjunto fuzzy</strong></em></div></br>
<img src="https://user-images.githubusercontent.com/61624336/101990623-a49d7980-3c86-11eb-8208-0eddbb6a00fc.jpg"/>
<p>Para este caso, na funÃ§Ã£o fuzzy, pessoas com altura menor que 1,70m possuem grau de pertinÃªncia 0 em relaÃ§Ã£o ao conjunto de pessoas altas, ou seja, nÃ£o sÃ£o definitivamente altas. Pessoas com altura maior que 1,90m possuem grau de pertinÃªncia 1 em relaÃ§Ã£o ao conjunto de pessoas altas, ou seja, sÃ£o definitivamente altas. JÃ¡ pessoas com altura entre 1,70m e 1,90m possuem algum grau de pertinÃªncia (0< Âµ <1) ao conjunto de pessoas altas. Outro exemplo estÃ¡ na figura.</p>

<div align="center"><em><strong>Conjunto fuzzy</strong></em></div></br>

![Sem TÃ­tulo-1](https://user-images.githubusercontent.com/61624336/101994207-6a8ca180-3c9f-11eb-9b82-5e8d47ac5e90.jpg)

<p>Para calcular o grau de pertinÃªncia de uma variÃ¡vel a um conjunto fuzzy, pode-se utilizar qualquer funÃ§Ã£o que associe o domÃ­nio da variÃ¡vel que se deseja fuzzificar com a imagem do intervalo [0,1] correspondente ao grau de pertinÃªncia da variÃ¡vel do domÃ­nio ao conjunto modelado pela funÃ§Ã£o fuzzy. O formato das funÃ§Ãµes de pertinÃªncia pode variar bastante. Algumas das principais funÃ§Ãµes utilizadas na literatura sÃ£o:</p>

![gif](https://user-images.githubusercontent.com/61624336/101996380-a67c3280-3cb0-11eb-8d75-468a13602a40.gif)

## ğŸ’¼ Sistemas de lÃ³gica Fuzzy ğŸ’¹
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102001311-73956700-3ccf-11eb-82c7-1fafe7858a55.jpg"/></div>
<p>Um <b>sistema fuzzy</b> lida com conjuntos fuzzy para fazer as tarefas de fuzzyficaÃ§Ã£o dos valores escalares do mundo real, para que possam ser manipulados como entidades linguÃ­sticas (Pessoas altas no caso da figura.) e, apÃ³s a aplicaÃ§Ã£o de <b>regras</b> de inferÃªncia que sÃ£o expressas com essas entidades linguÃ­sticas, mas lidam na verdade com os valores de pertinÃªncia, produzir atravÃ©s de um processo chamado <b>defuzzyficaÃ§Ã£o</b> os valores escalares que se apliquem Ã  saÃ­da para o mundo real. 
O modelo pode ser representado como na figura.</p>
<blockquote>As regras combinam variÃ¡veis linguÃ­sticas (quente, alto, barato, etc.), quantificadores (muito, pouco, extremamente, etc.), operadores lÃ³gicos (E, OU, NÃƒO) e de implicaÃ§Ã£o (SE, ENTÃƒO).
Por exemplo:

SE temperatura Ã© muito quente E fluxo Ã© baixo ENTÃƒO gire a torneira muito Ã  direita.

SE temperatura Ã© morna E fluxo Ã© mÃ©dio ENTÃƒO gire a torneira um pouco Ã  esquerda.</blockquote>
<blockquote>A defuzzificaÃ§Ã£o combina os valores produzidos pelas diversas regras que tenham sido acionadas para uma determinada entrada, produzindo, a partir da combinaÃ§Ã£o dos conjuntos fuzzy, uma saÃ­da escalar adequada.</blockquote>

## ğŸ’¹ Nomenclatura ğŸ’¹
<p><b>DomÃ­nio do conjunto fuzzy</b> Ã© o universo de valores possÃ­veis para um determinado conjunto. Para o conjunto fuzzy de pessoas altas, visto anteriormente o domÃ­nio Ã© aberto (de 0 a +âˆ). JÃ¡ para o conjunto de pessoas de meia idade o domÃ­nio Ã© fechado (20 a 70). 

Suporte do conjunto Ã© o subconjunto do domÃ­nio para o qual o grau de pertinÃªncia Ã© maior que zero. Para o conjunto de pessoas de meia idade, Ã© o intervalo de 30 a 60. </p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102002391-df310180-3cda-11eb-801c-700d7930597d.jpg"/></div>
<p><b>Conjunto Singleton</b> Ã© um conjunto fuzzy em que o suporte Ã© um Ãºnico ponto do domÃ­nio. Por exemplo, o conjunto de notas ideais em um domÃ­nio de 0 a 10, pode ser um conjunto Singleton em que apenas a nota 10 possui Âµ =1 e as demais possuem Âµ =0.
  O <b>Universo do discurso</b> Ã© o espaÃ§o completo de variaÃ§Ã£o dos valores de pertinÃªncia para uma determinada variÃ¡vel. Por exemplo, para uma variÃ¡vel temperatura assim modelada:

O universo do discurso Ã© de 100 a 360 graus.</p>

<p>As operaÃ§Ãµes com os conjuntos Fuzzy visam encontrar o grau de veracidade das afirmativas que fazem parte dos antecedentes das regras. Essas operaÃ§Ãµes bÃ¡sicas (UniÃ£o, InterseÃ§Ã£o, Complemento) sÃ£o realizadas com o grau de pertinÃªncia (Âµ) de um valor ao conjunto. Para saber se um valor pertence ao conjunto Fuzzy, devemos saber se o valor pertence ao DomÃ­nio do conjunto, ao seu Suporte e se estÃ¡ acima do limite a-cut.

As operaÃ§Ãµes podem ser aplicÃ¡veis a uma mesma variÃ¡vel ou variÃ¡veis distintas. Exemplos para uma variÃ¡vel:</br>
Se idade Ã© crianÃ§a OU idade Ã© velho entÃ£o risco de gripe Ã© alto</br>
Se idade NÃƒO Ã© meia-idade entÃ£o risco de infarto Ã© baixo</br>

Exemplo para duas variÃ¡veis:</br>
Se temperatura Ã© alta E pressÃ£o Ã© baixa entÃ£o vazÃ£o Ã© alta</p>

<p>Para a <b>operaÃ§Ã£o de complemento</b> (Ex: Se x NÃƒO Ã© A entÃ£o...), a forma de cÃ¡lculo do antecedente, geralmente Ã©: 1 - ÂµA(x).</br>
Para a UniÃ£o e a interseÃ§Ã£o, existem diferentes formas, propostas por diferentes autores, para realizar as operaÃ§Ãµes, como mostra a tabela a seguir:</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102003141-43a38f00-3ce2-11eb-8ce0-da077f42b9b3.jpg"/></div>

## ğŸ“‰ Quantificadores ğŸ“ˆ
<p>Os <b>quantificadores</b> sÃ£o termos que modificam os conjuntos Fuzzy originais, a partir de alguma operaÃ§Ã£o matemÃ¡tica feita com os mesmos. Os principais quantificadores sÃ£o dos seguintes tipos:</p>
<ul>
  <li><b>Intensificador:</b> muito, extremamente, super, hiper.</li>
  <li><b>Atenuador:</b> pouco, levemente, discretamente.</li>  
  <li><b>Aproximador:</b> em torno de, por volta de, aproximadamente.</li>
  <li><b>Restritivo:</b> no mÃ¡ximo, a partir de, nÃ£o maior que.</li>  
</ul>
<p>Para modelar o calculo da influÃªncia dos quantificadores de intensificaÃ§Ã£o nos conjuntos Fuzzy originais, podemos usar potÃªncias inteiras. Ou seja, Âµintensificador de A = (ÂµA)â¿. Desta forma, para diferentes valores de n poderÃ­amos modelar diferentes quantificadores de intensificaÃ§Ã£o, conforme mostrado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102014842-dff78100-3d36-11eb-9535-5de90e8b9c2f.jpg"/></div>
<p>Por outro lado, para calcular a influÃªncia dos quantificadores de atenuaÃ§Ã£o nos conjuntos Fuzzy, podemos usar potÃªncias fracionÃ¡rias. Ou seja, Âµatenuador de A = (ÂµA)â…Ÿâ¿. Assim sendo, para diferentes valores de n poderÃ­amos modelar diferentes quantificadores de atenuaÃ§Ã£o, conforme mostrado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102015052-dae70180-3d37-11eb-84d2-f6ac7411bc90.jpg"/></div>

<div align="center"><h1>Cap 05: ğŸ”€ Fuzzy system building ğŸ—ï¸</h1></div>

## ğŸ§ InferÃªncia Fuzzy ğŸ”€
<p>A <b>inferÃªncia Fuzzy</b> Ã© uma relaÃ§Ã£o lÃ³gica que obedece Ã  mesma tabela verdade da ImplicaÃ§Ã£o Modus Ponens da lÃ³gica proposicional tradicional (lÃ³gica crisp). A diferenÃ§a Ã© que na lÃ³gica crisp, a regra Ã© acionada somente se a premissa for verdadeira e na lÃ³gica fuzzy a regra Ã© acionada quando a premissa possui um grau de pertinÃªncia diferente de zero.

A regra Ã© uma composiÃ§Ã£o de relaÃ§Ãµes Fuzzy onde a primeira relaÃ§Ã£o Ã© um conjunto fuzzy (possivelmente resultante de uma operaÃ§Ã£o Fuzzy) e a segunda relaÃ§Ã£o Ã© de implicaÃ§Ã£o.

Exemplo:</br>
SE Homem Ã© novo ENTÃƒO Homem Ã© mau motorista.</br>
SE <b>peso Ã© gordo E idade Ã© meia idade</b> ENTÃƒO <b>risco Ã© alto</b>.</p>
<p>Para calcular a relaÃ§Ã£o de implicaÃ§Ã£o, a forma mais usada Ã© a sugerida por Mandani, apesar de existirem outras, propostas por Zadeh, Takagi-Sugeno, Tsukamoto e outros. Mandani propÃµem utilizar o mÃ­nimo ou o produto dos graus de pertinÃªncia.</p>
<p>Usando o mÃ­nimo: Âµpâ†’q (x,y) = min [Âµp(x), Âµq(y)]</p>
<p>Usando o produto: Âµpâ†’q (x,y) = Âµp(x)*Âµq(y)</p>

<p>O conjunto resultante da implicaÃ§Ã£o toma as formas da figura para os casos de inferÃªncia pelo mÃ­nimo e pelo produto.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102017160-f1935580-3d43-11eb-9926-6feab9722ab4.jpg"/></div>

## ğŸ“– Combinando regras acionadas ğŸ“–
<p>Caso haja um conjunto de regras e duas ou mais sejam acionadas, pode-se calcular o conjunto resultante da aplicaÃ§Ã£o das diferentes regras, utilizando-se o mÃ©todo do mÃ¡ximo ou o mÃ©todo da soma dos conjuntos Fuzzy do consequente de cada regra, alÃ©m de outras opÃ§Ãµes de combinaÃ§Ã£o menos usadas. Por exemplo, utilizando-se o mÃ­nimo para a implicaÃ§Ã£o e o mÃ¡ximo para a composiÃ§Ã£o de duas regras do tipo:</p>
<pre>Se x Ã© A E y Ã© B entÃ£o z Ã© C</pre>
<blockquote>ğŸ’¡ <strong>Dica:</strong> Temos o conjunto Fuzzy resultante ilustrado na figura.</blockquote>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102017493-040e8e80-3d46-11eb-9120-9010efc17c5f.jpg"/></div>

## ğŸ“ˆ DefuzzyficaÃ§Ã£o ğŸ”¢
<p>Um sistema Fuzzy possui entrada(s) escalar(es) e deve ser capaz de produzir uma saÃ­da tambÃ©m escalar. ApÃ³s serem realizadas as inferÃªncias com as regras e apÃ³s se haver determinado o conjunto Fuzzy resultante (conjunto Fuzzy de saÃ­da), deve-se encontrar um valor numÃ©rico (escalar) para a saÃ­da. A este processo chama-se <b>DefuzzyficaÃ§Ã£o</b> do conjunto de saÃ­da.

## ğŸ“š MÃ©todos de DefuzzyficaÃ§Ã£o ğŸ“ˆ
<p>Existem mÃ©todos propostos por diversos autores. Dois dos mais usados sÃ£o:</p>
<ul>
   <li><b>Centro de Ã¡rea:</b> Calcula o centro de gravidade da Ã¡rea do conjunto e usa o valor deste ponto (figura).</br>
  <div align="center"><img src="https://user-images.githubusercontent.com/61624336/102018118-f78c3500-3d49-11eb-8784-116e6ab5f802.jpg"/></div>
  Um problema Ã© que o centro da figura Ã© difÃ­cil de calcular se o universo do discurso nÃ£o for discreto ou se as funÃ§Ãµes fuzzy forem complexas.</li>
  <li><b>MÃ©dia dos mÃ¡ximos:</b> Observa o conjunto Fuzzy de saÃ­da C e determina os valores x de saÃ­da para os quais m C (x) Ã© mÃ¡ximo, ou seja, pega os valores de mÃ¡ximo de cada conjunto que contribuiu para formar o conjunto C de saÃ­da. Em seguida, calcula a mÃ©dia destes valores de mÃ¡ximo ponderados pelos graus de pertinÃªncia dos respectivos conjuntos e usa-se este valor de mÃ©dia como a saÃ­da desejada. 
  <div align="center"><img src="https://user-images.githubusercontent.com/61624336/102018283-29ea6200-3d4b-11eb-9f63-4d73dddbe811.jpg"/></div>
O valor de saÃ­da z Ã© calculado como: z = (MC1 . ÂµC1 + MC2 . ÂµC2) / (ÂµC1 + ÂµC2).</li>
</ul>

## ğŸ“š Exemplos de aplicaÃ§Ã£o ğŸ“ˆ
<p><b>Sistemas fuzzy</b> sÃ£o muito utilizados em aplicaÃ§Ãµes de controle. Algumas destas aplicaÃ§Ãµes, podem ser encontradas em uma ferramenta que possui uma versÃ£o de demonstraÃ§Ã£o chamada <b>FuzzyTech</b>. Um destes exemplos Ã© o controle de um guindaste que se movimenta em uma dimensÃ£o linear e deve posicionar uma determinada carga em uma plataforma. O controle fuzzy envolve o cÃ¡lculo da potÃªncia a ser aplicada ao motor (positiva ou negativa para movimentar o guindaste nos dois sentidos de direÃ§Ã£o), a partir das informaÃ§Ãµes de Ã¢ngulo (em graus) que a carga faz com o eixo vertical e distÃ¢ncia (em jardas) que a mesma se encontra da plataforma. A figura ilustra o sistema que se deseja controlar.</p>
<blockquote>ğŸ’¡<strong>Dica:</strong> Esta figura e as figuras seguintes foram retiradas do aplicativo <a href="https://www.fuzzytech.com/">FuzzyTech</a>.</blockquote>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102020026-68851a00-3d55-11eb-8714-254d767277b5.jpg"/></div>
<p>A variÃ¡vel de entrada Ã¢ngulo Ã© modelada pelos valores linguÃ­sticos pos-big, pos-small, zero, neg-small e neg-big. Seu universo do discurso Ã© dado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102020222-7b4c1e80-3d56-11eb-96cc-f9d416fe2982.jpg"/></div>
<p>A variÃ¡vel de entrada distÃ¢ncia Ã© modelada pelos valores linguÃ­sticos neg-close, zero, close, medium e far. Seu universo do discurso Ã© dado na figura.</div>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102021611-ac7d1c80-3d5f-11eb-93b5-9b03844a6977.jpg"/></div>
<p>A variÃ¡vel de saÃ­da potÃªncia Ã© modelada pelos valores linguÃ­sticos neg-big, neg-me, zero, pos-me e pos-hig. Seu universo do discurso Ã© dado na figura.</p>

<p>As regras do sistema de controle que calcula a potÃªncia trabalham com os valores linguÃ­sticos das variÃ¡veis do modelo e sÃ£o do seguinte tipo:</p>
Â 
<p>Se DISTÃ‚NCIA = far e Ã‚NGULO = neg_small</p>
<p>EntÃ£o POTÃŠNCIA = pos_high</p>
<p>Se DISTÃ‚NCIA = medium e Ã‚NGULO = neg_small</p>
<p>EntÃ£o POTÃŠNCIA = pos_high</p>
<p>Se DISTÃ‚NCIA = medium e Ã‚NGULO = neg_big</p>
<p>ntÃ£o POTÃŠNCIA = pos_medium</p>

<p>Assim, se em um determinado instante, temos valores especÃ­ficos para as variÃ¡veis de entrada, como por exemplo, distÃ¢ncia = 13 jardas e Ã¢ngulo = -45 graus, diferentes regras podem ser concomitantemente acionadas. 

Para o referido valor de distÃ¢ncia (13 jardas), dois conjuntos possuem Âµ > 0 (observe que a linha vertical que parte do valor 13 corta duas curvas de funÃ§Ãµes de pertinÃªncia). Ou seja, distÃ¢ncia=medium com Âµ =0,76 e distÃ¢ncia=far com Âµ =0,24. Observe a figura. </p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102022993-3a113a00-3d69-11eb-8968-b9520d728b04.jpg"/></div>
<p>Da mesma forma, para o Ã¢ngulo (-45 graus), dois conjuntos possuem m>0 (observe que a linha vertical que parte do valor -45 tambÃ©m corta duas curvas de funÃ§Ãµes de pertinÃªncia). Neste caso, Ã¢ngulo=neg_small com m=0,30 e Ã¢ngulo=neg_big com m=0,70. Observe a figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102023114-02ef5880-3d6a-11eb-91b4-c3b65731419b.jpg"/></div>
<p>Assim, para a primeira regra, 
Â 
Se DISTÃ‚NCIA = far e Ã‚NGULO = neg_small</br>
EntÃ£o POTÃŠNCIA = pos_high</br></p>
Â 
<p>Temos, na premissa, Âµ=0,24 e Âµ=0,30. Para combinar estes valores com o operador lÃ³gico E existem, como vimos, diversos mÃ©todos. Um dos mais comuns Ã© tomar o mÃ­nimo dos dois valores. Assim, o valor da combinaÃ§Ã£o lÃ³gica serÃ¡ MIN (0,24; 0,30) = 0,24 e este serÃ¡ o grau de pertinÃªncia da premissa da regra. Usando para a inferÃªncia tambÃ©m o operador de mÃ­nimo, a conclusÃ£o da regra serÃ¡ acionada com um grau de pertinÃªncia de, no mÃ¡ximo, Âµ=0,24. 
Entrando com o valor Âµ=0,24 no grÃ¡fico de funÃ§Ãµes da variÃ¡vel de saÃ­da potÃªncia, para o conjunto determinado pela regra (pos_high), temos o resultado da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102025887-90867480-3d79-11eb-925d-e6f6dd91ce48.jpg"/></div>
<p>Da mesma forma, para a segunda regra,
Se DISTÃ‚NCIA = medium e Ã‚NGULO = neg_small</br>
EntÃ£o POTÃŠNCIA = pos_high</br>
temos uma premissa com MIN(0,76; 0,30) = 0,30. Logo, o grÃ¡fico da variÃ¡vel de saÃ­da terÃ¡ a forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102025974-1e625f80-3d7a-11eb-984c-a45f48e16e23.jpg"/></div>
<p>Finalmente, para a terceira regra,</br>
Se DISTÃ‚NCIA = medium e Ã‚NGULO = neg_big</br>
EntÃ£o POTÃŠNCIA = pos_medium</br>
temos o grau de pertinÃªncia da premissa como MIN(0,76; 0,70) = 0,70. Assim o grÃ¡fico da variÃ¡vel de saÃ­da terÃ¡ a forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026364-2e7b3e80-3d7c-11eb-8444-077c299b6bdf.jpg"/></div>
<p>Como resultado da aplicaÃ§Ã£o das trÃªs regras, temos a forma da figura:</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026580-6c2c9700-3d7d-11eb-9a8b-37153cfd8d0f.jpg"/></div>
<p>Como as trÃªs regras foram acionadas, temos a uniÃ£o dos trÃªs conjuntos. Para representar a uniÃ£o, geralmente utiliza-se o mÃ¡ximo dos conjuntos (Mandani), o que, portanto, resulta na forma da figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026635-c594c600-3d7d-11eb-9610-0c1b0ae2bc28.jpg"/></div>
<p>Finalmente, para que possamos encontrar um valor de saÃ­da para a potÃªncia (defuzzificaÃ§Ã£o) podemos utilizar vÃ¡rios mÃ©todos. Achar o centro de massa da figura resultante Ã© um deles (difÃ­cil de calcular). Outro mÃ©todo, chamado MÃ©dia dos MÃ¡ximos, calcula a mÃ©dia dos valores tÃ­picos das funÃ§Ãµes ativadas (valores de mÃ¡ximo) ponderados pelos graus de pertinÃªncia com que estes conjuntos foram ativados. Assim, para o caso temos o indicado na figura.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102026753-7307d980-3d7e-11eb-80e6-6df0f31c8249.jpg"/></div>
<p>O valor da variÃ¡vel de saÃ­da potÃªncia, para este instante, dados os valores das variÃ¡veis de entrada (12 jardas e â€“45 graus) e as regras citadas, seria portanto (observe que os valores de mÃ¡ximo de cada conjunto, usados no cÃ¡lculo da mÃ©dia dos mÃ¡ximos, sÃ£o os indicados pelas setas na figura anterior):
</br>
MÃ©dia = (10 x 0,7 + 23,5 x 0,3) / (0,7 + 0,3) = 14,05</br>
</br>
Ou seja, para uma distÃ¢ncia de 12 jardas e um Ã¢ngulo de -45 graus, o controle Fuzzy produz como saÃ­da uma potÃªncia de 14,05 KW a ser aplicada ao motor do guindaste. Esse valor seria aplicado na planta geraria uma alteraÃ§Ã£o da distÃ¢ncia e do Ã¢ngulo da carga, o que realimentaria o controle fuzzy na prÃ³xima iteraÃ§Ã£o.</p>
<div align="center"><h1>Cap 06: ğŸ‘¨â€âš•ï¸ Evolved Systems and Genetic Algorithms ğŸ§¬</h1></div>
<img src="https://www.genengnews.com/wp-content/uploads/2019/05/GettyImages-1084312676.jpg" width="1070"/>
<h2>ğŸ˜µ O problema de otimizaÃ§Ã£o ğŸ¤¯</h2>
<p>Um <b>problema de otimizaÃ§Ã£o</b> consiste em encontrar, entre as muitas soluÃ§Ãµes possÃ­veis para um problema, aquela ou aquelas que representam a melhor soluÃ§Ã£o. Naturalmente o conceito de melhor se aplica a algum ou a alguns critÃ©rios, tais como o custo financeiro, o tempo, a distÃ¢ncia, a seguranÃ§a ou a qualquer outro aspecto que se deseje otimizar.

Qualquer processo de otimizaÃ§Ã£o pode ser resumido em como encontrar os parÃ¢metros que minimizam (ou maximizam, depende do problema) uma determinada funÃ§Ã£o multi parametrizada (de muitos parÃ¢metros), ou seja, encontrar o MIN ( f( x1, x2, x3,...xn)). 

Todo problema de maximizaÃ§Ã£o pode ser transformado em um problema de minimizaÃ§Ã£o e vice versa. Por exemplo, tomando-se a funÃ§Ã£o mono-parametrizada y = f(x) = 2-x2, no intervalo (-2<x<2), teremos um Ãºnico ponto (x=0) que maximiza a funÃ§Ã£o.</p>
<p>Entretanto, se multiplicarmos a funÃ§Ã£o f(x) por -1, calculando entÃ£o a funÃ§Ã£o g(x) = -f(x) = x2 â€“ 1, terÃ­amos um Ãºnico e mesmo ponto (x=0) que minimiza a funÃ§Ã£o para o mesmo intervalo. Assim, em geral, podemos estudar otimizaÃ§Ã£o apenas como um problema de minimizaÃ§Ã£o ou apenas como um problema de maximizaÃ§Ã£o, pois o(s) ponto(s) de minimizaÃ§Ã£o da funÃ§Ã£o e o(s) de maximizaÃ§Ã£o da funÃ§Ã£o inversa sÃ£o os mesmos. 

Quando a abordagem escolhida Ã© estudar os problemas de otimizaÃ§Ã£o como problemas de minimizaÃ§Ã£o, o valor da funÃ§Ã£o pode ser visto como um â€œcustoâ€ a ser minimizado.

Mesmo trabalhando com uma <em>funÃ§Ã£o mono-parametrizada</em>, Ã© possÃ­vel que esta possua, dentro de um determinado intervalo, vÃ¡rios pontos de mÃ­nimos ou mÃ¡ximos relativos, conhecidos como mÃ­nimos locais e mÃ¡ximos locais, havendo somente um ponto de mÃ­nimo global ou de mÃ¡ximo global no intervalo. Uma funÃ§Ã£o desse tipo Ã© chamada de <b>unimodal</b>.</p>
<p>Tomemos por exemplo a funÃ§Ã£o f(x) = x sen (3 x) no intervalo -5<x<10, cujo grÃ¡fico encontra-se na figura 1. Sob o ponto de vista de maximizaÃ§Ã£o ela Ã© unimodal pois, no intervalo considerado, ela possui um ponto de mÃ¡ximo para x = 8,91 no qual f(x) = 8,92.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102034373-a0fc1680-3d9c-11eb-9801-0c14ccd1bd18.jpg"/></div>
<div align="center"><em><strong>Figura 1:</strong> FunÃ§Ã£o mono-parametrizada unimodal: f(x) = x sen (3 x)</em></div></br>

<p>JÃ¡ uma funÃ§Ã£o multimodal possui mais de um mÃ¡ximo global para um determinado intervalo. Tomemos, por exemplo, a funÃ§Ã£o f(x) = sen (x/2) + cos (2x)/1,5 no intervalo -14&lt;x&lt;20, vista na figura 2. A funÃ§Ã£o possui pontos de mÃ¡ximo em x = -9.42, x = 3 e x = 15,71. Nesses pontos temos f(x) = 1,66666..., que vem a ser o valor mÃ¡ximo que a funÃ§Ã£o atinge nesse intervalo.</p>
<div align="center"><img src="https://user-images.githubusercontent.com/61624336/102041828-36a0a180-3daf-11eb-939a-373c3d02fe9f.jpg"/></div>
<div align="center"><em><strong>Figura 2:</strong> FunÃ§Ã£o mono-parametrizada multimodal: f(x) = sen (x/2) + cos (2x)/1,5</em></div></br>
<p>A funÃ§Ã£o que se deseja otimizar Ã© conhecida como FunÃ§Ã£o Objetivo e o intervalo em que se seja buscar uma soluÃ§Ã£o Ã© o EspaÃ§o de Busca. Para a funÃ§Ã£o da figura 6.2 o espaÃ§o de busca por valores de x Ã© o intervalo entre -14 e 20. 
Os parÃ¢metros da funÃ§Ã£o podem ainda estar sujeitos a restriÃ§Ãµes expressas por meio de equaÃ§Ãµes ou inequaÃ§Ãµes, tais como:
Minimizar f(x) = x2 + y2 + 4
sujeito Ã s restriÃ§Ãµes de: 2x - 3y < 5 e de: x + y = 7. <br />
Quando a funÃ§Ã£o objetivo e as funÃ§Ãµes das restriÃ§Ãµes possuem apenas relaÃ§Ãµes lineares (operadores aritmÃ©ticos de adiÃ§Ã£o, subtraÃ§Ã£o multiplicaÃ§Ã£o e divisÃ£o), o problema Ã© de ProgramaÃ§Ã£o Linear. Caso, entretanto, haja algum outro operador nas funÃ§Ãµes, tais como exponenciaÃ§Ã£o, logaritmos, expressÃµes trigonomÃ©tricas ou quaisquer outros operadores nÃ£o lineares, o problema Ã© de ProgramaÃ§Ã£o nÃ£o Linear.</p>
<p>Os parÃ¢metros da funÃ§Ã£o objetivo podem ainda ser <b>contÃ­nuos</b> ou <b>discretos</b>.</p>
<blockquote><b>ParÃ¢metros contÃ­nuos</b> podem levar a situaÃ§Ãµes onde haja uma quantidade infinita de soluÃ§Ãµes possÃ­veis (combinaÃ§Ãµes de diferentes valores para os parÃ¢metro que otimizam a funÃ§Ã£o objetivo e nÃ£o ferem nenhuma restriÃ§Ã£o). </blockquote>
<blockquote><b>ParÃ¢metros discretos</b> possuem sempre uma quantidade finita de soluÃ§Ãµes, dado que a quantidade de valores discretos em um intervalo Ã© tambÃ©m finita e qualquer soluÃ§Ã£o Ã© uma combinaÃ§Ã£o desses valores. Dentro dos problemas com parÃ¢metros discretos, uma classe de problemas importante Ã© a dos que buscam uma sequÃªncia de especÃ­fica de valores, tais como uma sequencia de tarefas ou uma sequencia de locais a serem visitados. Tais problemas sÃ£o conhecidos como <b>problemas de OtimizaÃ§Ã£o CombinatÃ³ra</b></blockquote>

## ğŸ‘¨â€âš•ï¸ SoluÃ§Ãµes para o problema de otimizaÃ§Ã£o ğŸ˜µ
<p>Existem muitas e diversificadas classes de tÃ©cnicas aplicÃ¡veis a problemas de otimizaÃ§Ã£o. Algumas naturalmente se aplicam melhor a alguns problemas do que a outros, mas todas tÃªm alguma restriÃ§Ã£o. Vamos comentar a seguir algumas dessas classes de soluÃ§Ãµes.</p>
<ol>
  <li>Uma primeira ideia, usando <b>forÃ§a bruta computacional</b>, pode ser simplesmente gerar aleatoriamente soluÃ§Ãµes, ou seja, valores aleatÃ³rios para os parÃ¢metros dentro do espaÃ§o de busca e testar as soluÃ§Ãµes geradas para cada conjunto de parÃ¢metros, comparando os resultados dos testes. Esse mÃ©todo Ã© conhecido como <b>Busca AleatÃ³ria</b> e sua principal deficiÃªncia estÃ¡ no grande esforÃ§o computacional necessÃ¡rio a encontrar uma soluÃ§Ã£o satisfatÃ³ria, que pode inclusive, dependendo do espaÃ§o de busca do problema, virtualmente inviabilizar a obtenÃ§Ã£o de uma soluÃ§Ã£o satisfatÃ³ria.</li>
  <li>Existem, por outro lado, mÃ©todos clÃ¡ssicos, chamados de <b>TÃ©cnicas AnalÃ­ticas</b>, como o mÃ©todo de Newton-Raphson, que utilizam tÃ©cnicas exclusivamente matemÃ¡ticas para determinar os pontos de mÃ¡ximo e mÃ­nimo das funÃ§Ãµes. Tais mÃ©todos se baseiam em geral em tÃ©cnicas de cÃ¡lculo diferencial, o que exige, por sua vez, que as funÃ§Ãµes sejam contÃ­nuas e diferenciÃ¡veis no espaÃ§o de busca, caracterÃ­sticas que muitas vezes nÃ£o sÃ£o encontradas em problemas do mundo real. Nessas tÃ©cnicas pode ainda ser difÃ­cil determinar os pontos de mÃ¡ximo ou mÃ­nimo quando as funÃ§Ãµes possuem muitos parÃ¢metros e sÃ£o intensamente multi-modais.</li>
  <li>JÃ¡ os mÃ©todos conhecidos como <b>Subida de Encosta</b>, tais como o mÃ©todo do Gradiente Descendente ou o mÃ©todo de Recozimento Simulado procuram em um pequeno espaÃ§o de busca em torno de uma soluÃ§Ã£o, buscando localizar a direÃ§Ã£o em que a funÃ§Ã£o cresce ou decresce. Tais mÃ©todos sÃ£o rÃ¡pidos, porÃ©m sÃ£o muito sensÃ­veis Ã  existÃªncia de mÃ¡ximos ou mÃ­nimos locais.</li>
  <li>Os MÃ©todos HeurÃ­sticos, tais como os <b>Algoritmos GenÃ©ticos</b>, tÃªm como principal caracterÃ­stica a manutenÃ§Ã£o de uma populaÃ§Ã£o de soluÃ§Ãµes e a exploraÃ§Ã£o do espaÃ§o de busca tanto de forma local no entorno das soluÃ§Ãµes existentes quanto de forma global, ao abrir novos pontos de busca distantes das soluÃ§Ãµes locais. Algumas das principais vantagens que os algoritmos genÃ©ticos apresentam sÃ£o:</li>
  <ul>
<li>A possibilidade de realizar exploraÃ§Ã£o simultÃ¢nea em distintos pontos do espaÃ§o de busca (que pode ser melhor explorada com o uso de computaÃ§Ã£o paralela);</li>
  <li>O funcionamento em espaÃ§os de busca contÃ­nuos ou discretos;</li>
  <li>O fato de nÃ£o serem sensÃ­veis Ã  existÃªncia de mÃ­nimos locais;</li>
  <li>A capacidade de descobrir vÃ¡rias soluÃ§Ãµes (particularmente Ãºtil para funÃ§Ãµes multi-modais);</li>
<li>A caracterÃ­stica de nÃ£o imporem condiÃ§Ãµes especiais Ã  funÃ§Ã£o a ser otimizada (continuidade, existÃªncia de derivada, etc.);</li>
  <li>A possibilidade de funcionarem bem em espaÃ§os de busca com muitas dimensÃµes;</li>
<li>A capacidade de permitirem modelar restriÃ§Ãµes e otimizar simultaneamente mÃºltiplas funÃ§Ãµes, mesmo que conflitantes;</li>
<li>A capacidade de ser facilmente mesclados com outras tÃ©cnicas heurÃ­sticas, compondo soluÃ§Ãµes hÃ­bridas que exploram as qualidades individuais de cada tÃ©cnica especÃ­fica;</li>
<li>A caracterÃ­stica de serem fÃ¡ceis de implantar computacionalmente, nÃ£o dependendo de profunda compreensÃ£o do problema a ser otimizado e de sua modelagem.</li>
</ul>
<p>Entretanto, tais mÃ©todos sÃ£o computacionalmente intensos e podem demorar a convergir para uma soluÃ§Ã£o aceitÃ¡vel (dependendo da parametrizaÃ§Ã£o, como veremos adiante). Portanto, sua principal restriÃ§Ã£o Ã© a utilizaÃ§Ã£o em problemas de otimizaÃ§Ã£o que exijam respostas em tempo real.</p>
</ol>



















